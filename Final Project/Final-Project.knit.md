
<!-- rnb-text-begin -->

---
title: "Final Project"
output: html_notebook
---



<!-- rnb-text-end -->


<!-- rnb-chunk-begin -->


<!-- rnb-source-begin eyJkYXRhIjoiYGBgclxuI0xpYnJhcmllcyB0byBMb2FkIGluXG5saWJyYXJ5KHNoaW55ZGFzaGJvYXJkKVxubGlicmFyeShzaGlueSlcbmxpYnJhcnkoZ2dwbG90MilcbmxpYnJhcnkocGxvdGx5KVxubGlicmFyeShEVClcbmBgYCJ9 -->

```r
#Libraries to Load in
library(shinydashboard)
library(shiny)
library(ggplot2)
library(plotly)
library(DT)
```

<!-- rnb-source-end -->

<!-- rnb-chunk-end -->


<!-- rnb-text-begin -->



>Final Dashboard Code


<!-- rnb-text-end -->


<!-- rnb-chunk-begin -->


<!-- rnb-source-begin eyJkYXRhIjoiYGBgclxudWkgPC0gZGFzaGJvYXJkUGFnZShcbiAgc2tpbiA9IFwicmVkXCIsXG4gIGRhc2hib2FyZEhlYWRlcih0aXRsZSA9IFwiRmluYWwgUHJvamVjdCBEYXNoYm9hcmRcIiksXG4gIFxuICAjIyBTaWRlYmFyIGNvbnRlbnRcbiAgZGFzaGJvYXJkU2lkZWJhcihcbiAgICBzaWRlYmFyTWVudShcbiAgICAgIG1lbnVJdGVtKFwiIERhc2hib2FyZFwiLCB0YWJOYW1lID0gXCJkYXNoYm9hcmRcIiwgaWNvbiA9IGljb24oXCJkYXNoYm9hcmRcIikpLFxuICAgICAgbWVudUl0ZW0oXCIgUmlnaHQgSGFuZCBNb3ZlbWVudFwiLCB0YWJOYW1lID0gXCJSaWdodEhhbmRNb3ZlbWVudFwiLCBpY29uID0gaWNvbihcImhhbmQtcG9pbnQtcmlnaHRcIikpLFxuICAgICAgbWVudUl0ZW0oXCIgSGVhZCBNb3ZlbWVudFwiLCB0YWJOYW1lID0gXCJIZWFkTW92ZW1lbnRcIiwgaWNvbiA9IGljb24oXCJnbHlwaGljb24gZ2x5cGhpY29uLXVzZXJcIiwgbGliID0gXCJnbHlwaGljb25cIikpLFxuICAgICAgbWVudUl0ZW0oXCIgTGVmdCBIYW5kIE1vdmVtZW50XCIsIHRhYk5hbWUgPSBcIkxlZnRIYW5kTW92ZW1lbnRcIiwgaWNvbiA9IGljb24oXCJoYW5kLXBvaW50LWxlZnRcIikpLFxuICAgICAgbWVudUl0ZW0oXCIgTWV0cmljc1wiLCB0YWJOYW1lID0gXCJNZXRyaWNzXCIsIGljb24gPSBpY29uKFwiY2xpcGJvYXJkXCIpKSxcbiAgICAgIG1lbnVJdGVtKFwiIFF1aXpcIiwgdGFiTmFtZSA9IFwiUXVpelwiLCBpY29uID0gaWNvbihcImZlYXRoZXJcIikpXG4gICAgICBcbiAgICApXG4gICksXG4gIGRhc2hib2FyZEJvZHkoXG4gICAgdGFiSXRlbXMoXG4gICAgICAjIEZpcnN0IHRhYiBjb250ZW50XG4gICAgICB0YWJJdGVtKHRhYk5hbWUgPSBcImRhc2hib2FyZFwiLFxuICAgICAgICAgICAgICBmbHVpZFJvdyhcbiAgICAgICAgICAgICAgICBib3goIHdpZHRoID0gMTIsIGJhY2tncm91bmQgPSBcIm5hdnlcIixcbiAgICAgICAgICAgICAgICBoMShcbiAgICAgICAgICAgICAgICAgIFwiVGhpcyBpcyB0aGUgSG9tZS9EYXNoYm9hcmQgUGFnZS5cIlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGJveCggd2lkdGggPSAxMiwgYmFja2dyb3VuZCA9IFwiYmx1ZVwiLFxuICAgICAgICAgICAgICAgICAgaDIoXG4gICAgICAgICAgICAgICAgICAgIFwiTmF2aWdhdGUgdG8gb3RoZXIgcGFnZXMgd2l0aCB0aGUgc2lkZWJhciBvbiB0aGUgbGVmdFwiXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgYm94KCB3aWR0aCA9IDEyLCBiYWNrZ3JvdW5kID0gXCJsaWdodC1ibHVlXCIsXG4gICAgICAgICAgICAgICAgICBoMyhcbiAgICAgICAgICAgICAgICAgICAgXCJPbmx5IHVzZSB0aGUgcmVzcGVjdGl2ZSAuY3N2IGZpbGVzIGZvciB0aGVpciBzcGVjaWZpYyB0YWJcIlxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICkpLCBcblxuICAgICAgIyBTZWNvbmQgdGFiIGNvbnRlbnQgLSBSaWdodCBIYW5kIE1vdmVtZW50XG4gICAgICB0YWJJdGVtKHRhYk5hbWUgPSBcIlJpZ2h0SGFuZE1vdmVtZW50XCIsXG4gICAgICAgICAgICAgIGgyKFwiUmlnaHQgSGFuZCBNb3ZlbWVudCB0YWIgY29udGVudFwiKSxcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICNSb3cgXG4gICAgICAgICAgICAgICMgd2l0aCBGaWxlIElucHV0IGFuZCBNZWFuLFNURCwgYW5kIFZhclxuICAgICAgICAgICAgICBmbHVpZFJvdyhcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBib3goIHRpdGxlID0gXCJGaWxlIElucHV0IEhlcmVcIiwgd2lkdGggPSA2LCBzdGF0dXMgPSBcInByaW1hcnlcIixcbiAgICAgICAgICAgICAgICAgIGZpbGVJbnB1dChcImRhdGFfZlwiLCBcIlVwbG9hZCBkYXRhXCIsIGFjY2VwdCA9IFwiLmNzdlwiKSksXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgYm94KCB0aXRsZSA9IFwiTWVhbiwgU3RhbmRhcmQgRGV2aWF0aW9uLCBhbmQgVmFyaWFuY2VcIiwgd2lkdGggPSA2LCBzdGF0dXMgPSBcImluZm9cIixcbiAgICAgICAgICAgICAgICAgIHRhYmxlT3V0cHV0KFwib3V0X01lYW5fVGVzdFwiKSxcbiAgICAgICAgICAgICAgICAgIHRhYmxlT3V0cHV0KFwib3V0X3N0ZF9UZXN0XCIpLFxuICAgICAgICAgICAgICAgICAgdGFibGVPdXRwdXQoXCJvdXRfdmFyX1Rlc3RcIilcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgI1JvdyBcbiAgICAgICAgICAgICAgIyB3aXRoIDNEIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgICAgIGZsdWlkUm93KFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGJveCggdGl0bGUgPSBcIlBvc2l0aW9uIGdyYXBoIGJhc2VkIG9uIHRpbWVcIiwgd2lkdGggPSAxMiwgc3RhdHVzID0gXCJpbmZvXCIsXG4gICAgICAgICAgICAgICAgICBwbG90bHlPdXRwdXQoXCJvdXRfZGF0YV9mNVwiKSksXG4gICAgICAgICAgICAgICAgbWFpblBhbmVsKFxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgI1Jvd1xuICAgICAgICAgICAgICAjIHdpdGggZGF0YSBUYWJsZSBPdXRwdXQgYW5kIEZpbGUgTWV0YSBEYXRhXG4gICAgICAgICAgICAgIGZsdWlkUm93KFxuICAgICAgICAgICAgICBib3goIHdpZHRoID0gMTIsIHN0YXR1cyA9IFwiaW5mb1wiLFxuICAgICAgICAgICAgICAgIHRpdGxlID0gXCJSaWdodCBIYW5kIE1vdmVtZW50IGlucHV0IFRhYmxlOiBcIixcbiAgICAgICAgICAgICAgICBjb2xsYXBzaWJsZSA9IFQsXG4gICAgICAgICAgICAgICAgZmx1aWRSb3codGFibGVPdXRwdXQoXCJvdXRfZGF0YV9mMVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVGFibGVPdXRwdXQoXCJvdXRfZGF0YV9mMlwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkpKSwgXG4gICAgICBcbiAgICAgICNUaGlyZCBUYWIgQ29udGVudCAtIEhNRCAvIENhbWVyYSBNb3ZlbWVudFxuICAgICAgdGFiSXRlbSh0YWJOYW1lID0gXCJIZWFkTW92ZW1lbnRcIixcbiAgICAgICAgICAgICAgaDIoXCJIZWFkIE1vdmVtZW50IHRhYiBjb250ZW50XCIpLFxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgI1Jvd1xuICAgICAgICAgICAgICAjIHdpdGggRmlsZSBJbnB1dCBhbmQgTWVhbixTVEQsIGFuZCBWYXJcbiAgICAgICAgICAgICAgZmx1aWRSb3coXG4gICAgICAgICAgICAgICAgYm94KCB0aXRsZSA9IFwiRmlsZSBJbnB1dCBIZXJlXCIsIHdpZHRoID0gNiwgc3RhdHVzID0gXCJwcmltYXJ5XCIsXG4gICAgICAgICAgICAgICAgZmlsZUlucHV0KFwiZGF0YV9ITURcIiwgXCJVcGxvYWQgZGF0YVwiLCBhY2NlcHQgPSBcIi5jc3ZcIiksXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBib3goIHRpdGxlID0gXCJNZWFuLCBTdGFuZGFyZCBEZXZpYXRpb24sIGFuZCBWYXJpYW5jZVwiLCB3aWR0aCA9IDYsIHN0YXR1cyA9IFwiaW5mb1wiLFxuICAgICAgICAgICAgICAgICAgdGFibGVPdXRwdXQoXCJvdXRfTWVhbl9ITURcIiksXG4gICAgICAgICAgICAgICAgICB0YWJsZU91dHB1dChcIm91dF9zdGRfSE1EXCIpLFxuICAgICAgICAgICAgICAgICAgdGFibGVPdXRwdXQoXCJvdXRfdmFyX0hNRFwiKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgI1Jvd1xuICAgICAgICAgICAgICAjIHdpdGggM0QgcmVwcmVzZW50YXRpb25cbiAgICAgICAgICAgICAgZmx1aWRSb3coXG4gICAgICAgICAgICAgICAgYm94KHRpdGxlID0gXCJQb3NpdGlvbiBncmFwaCBiYXNlZCBvbiB0aW1lXCIsIHdpZHRoID0gMTIsIHN0YXR1cyA9IFwiaW5mb1wiLFxuICAgICAgICAgICAgICAgICAgICBwbG90bHlPdXRwdXQoXCJvdXRfZGF0YV9ITURQbG90XCIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICNSb3dcbiAgICAgICAgICAgICAgIyB3aXRoIGRhdGEgVGFibGUgT3V0cHV0IGFuZCBGaWxlIE1ldGEgRGF0YVxuICAgICAgICAgICAgICBmbHVpZFJvdyhcbiAgICAgICAgICAgICAgICBib3goXG4gICAgICAgICAgICAgICAgICB3aWR0aCA9IDEyLFxuICAgICAgICAgICAgICAgICAgdGl0bGUgPSBcIkhNRCAvIENhbWVyYSBNb3ZlbWVudCBpbnB1dCBUYWJsZTogXCIsIHN0YXR1cyA9IFwiaW5mb1wiLFxuICAgICAgICAgICAgICAgICAgY29sbGFwc2libGUgPSBULFxuICAgICAgICAgICAgICAgICAgZmx1aWRSb3coXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlT3V0cHV0KFwib3V0X2RhdGFfSE1EX01ldGFcIiksXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUYWJsZU91dHB1dChcIm91dF9kYXRhX0hNRF9EVFwiKSlcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApLCBcbiAgICAgICNGb3VydGggVGFiIENvbnRlbnQgLSBMZWZ0IEhhbmQgTW92ZW1lbnRcbiAgICAgIHRhYkl0ZW0odGFiTmFtZSA9IFwiTGVmdEhhbmRNb3ZlbWVudFwiLFxuICAgICAgICBoMihcIkxlZnQgSGFuZCBNb3ZlbWVudCB0YWIgY29udGVudFwiKSxcbiAgICAgICAgXG4gICAgICAgICAgICAgICNSb3cgXG4gICAgICAgICAgICAgICMgd2l0aCBGaWxlIElucHV0IGFuZCBNZWFuLFNURCwgYW5kIFZhclxuICAgICAgICAgICAgICBmbHVpZFJvdyhcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBib3goIHRpdGxlID0gXCJGaWxlIElucHV0IEhlcmVcIiwgd2lkdGggPSA2LCBzdGF0dXMgPSBcInByaW1hcnlcIixcbiAgICAgICAgICAgICAgICAgIGZpbGVJbnB1dChcImRhdGFfTGVmdFwiLCBcIlVwbG9hZCBkYXRhXCIsIGFjY2VwdCA9IFwiLmNzdlwiKSksXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgYm94KCB0aXRsZSA9IFwiTWVhbiwgU3RhbmRhcmQgRGV2aWF0aW9uLCBhbmQgVmFyaWFuY2VcIiwgd2lkdGggPSA2LCBzdGF0dXMgPSBcImluZm9cIixcbiAgICAgICAgICAgICAgICAgIHRhYmxlT3V0cHV0KFwib3V0X01lYW5fTGVmdEhhbmRcIiksXG4gICAgICAgICAgICAgICAgICB0YWJsZU91dHB1dChcIm91dF9zdGRfTGVmdEhhbmRcIiksXG4gICAgICAgICAgICAgICAgICB0YWJsZU91dHB1dChcIm91dF92YXJfTGVmdEhhbmRcIilcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgI1JvdyBcbiAgICAgICAgICAgICAgIyB3aXRoIDNEIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgICAgIGZsdWlkUm93KFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGJveCggdGl0bGUgPSBcIlBvc2l0aW9uIGdyYXBoIGJhc2VkIG9uIHRpbWVcIiwgd2lkdGggPSAxMiwgc3RhdHVzID0gXCJpbmZvXCIsXG4gICAgICAgICAgICAgICAgICBwbG90bHlPdXRwdXQoXCJvdXRfZGF0YV9MZWZ0SGFuZDNEXCIpKSxcbiAgICAgICAgICAgICAgICBtYWluUGFuZWwoXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgI1Jvd1xuICAgICAgICAgICAgICAjIHdpdGggZGF0YSBUYWJsZSBPdXRwdXQgYW5kIEZpbGUgTWV0YSBEYXRhXG4gICAgICAgICAgICAgIGZsdWlkUm93KFxuICAgICAgICAgICAgICBib3goIHdpZHRoID0gMTIsXG4gICAgICAgICAgICAgICAgdGl0bGUgPSBcIkxlZnQgSGFuZCBNb3ZlbWVudCBpbnB1dCBUYWJsZTogXCIsXG4gICAgICAgICAgICAgICAgY29sbGFwc2libGUgPSBULCBzdGF0dXMgPSBcImluZm9cIixcbiAgICAgICAgICAgICAgICBmbHVpZFJvdyh0YWJsZU91dHB1dChcIm91dF9kYXRhX0xlZnRfTWV0YVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVGFibGVPdXRwdXQoXCJvdXRfZGF0YV9MZWZ0X0RUXCIpKVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICApKVxuICAgICAgKSxcbiAgICAgIFxuICAgICAgI0ZpZnRoIFRhYiBDb250ZW50IC0gTWV0cmljcyBSZXN1bHRzXG4gICAgICB0YWJJdGVtKHRhYk5hbWUgPSBcIk1ldHJpY3NcIixcbiAgICAgICAgaDIoXCJNZXRyaWNzIHRhYiBjb250ZW50XCIpLFxuICAgICAgICBcbiAgICAgICAgI1Jvd1xuICAgICAgICAjIHdpdGggRmlsZSBJbnB1dCBcbiAgICAgICAgZmx1aWRSb3coXG4gICAgICAgICAgYm94KFxuICAgICAgICAgICAgdGl0bGUgPSBcIkZpbGUgSW5wdXQgSGVyZVwiLFxuICAgICAgICAgICAgd2lkdGggPSA0LCBzdGF0dXMgPSBcInByaW1hcnlcIixcbiAgICAgICAgICAgIGZpbGVJbnB1dChcImRhdGFfTWV0cmljc1wiLCBcIlVwbG9hZCBkYXRhXCIsIGFjY2VwdCA9IFwiLmNzdlwiKVxuICAgICAgICAgICksXG4gICAgICAgICAgXG4gICAgICAgICAgYm94KFxuICAgICAgICAgICAgdGl0bGUgPSBcIk1ldHJpY3MgU2NvcmU6XCIsXG4gICAgICAgICAgICB3aWR0aCA9IDgsIHN0YXR1cyA9IFwiaW5mb1wiLFxuICAgICAgICAgICAgdGFibGVPdXRwdXQoXCJvdXRfZGF0YV9NZXRyaWNzX1RhYmxlXCIpXG4gICAgICAgICAgKVxuICAgICAgICApLCBcbiAgICAgICAgZmx1aWRSb3coXG4gICAgICAgICAgYm94KCB0aXRsZSA9IFwiVGhpbmdzIHRvIHdvcmsgb25cIiwgd2lkdGggPSA2LCBiYWNrZ3JvdW5kID0gXCJvcmFuZ2VcIixcbiAgICAgICAgICAgIHRhYmxlT3V0cHV0KFwib3V0X2RhdGFfTWV0cmljc19Xb3JrT25UYWJsZVwiKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIFxuICAgICAgI1NpeHRoIFRhYiBDb250ZW50IC0gUXVpeiBSZXN1bHRzXG4gICAgICB0YWJJdGVtKHRhYk5hbWUgPSBcIlF1aXpcIixcbiAgICAgICAgICAgICAgaDIoXCJRdWl6IHRhYiBjb250ZW50XCIpLFxuICAgICAgICAgICAgICAjUm93XG4gICAgICAgICAgICAgICMgd2l0aCBGaWxlIElucHV0XG4gICAgICAgICAgICAgIGZsdWlkUm93KFxuICAgICAgICAgICAgICAgIGJveChcbiAgICAgICAgICAgICAgICAgIHRpdGxlID0gXCJGaWxlIElucHV0IEhlcmVcIixcbiAgICAgICAgICAgICAgICAgIHdpZHRoID0gNCwgc3RhdHVzID0gXCJwcmltYXJ5XCIsXG4gICAgICAgICAgICAgICAgICBmaWxlSW5wdXQoXCJkYXRhX1F1aXpcIiwgXCJVcGxvYWQgZGF0YVwiLCBhY2NlcHQgPSBcIi5jc3ZcIilcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGJveChcbiAgICAgICAgICAgICAgICAgIHRpdGxlID0gXCJRdWl6IFNjb3JlOlwiLFxuICAgICAgICAgICAgICAgICAgd2lkdGggPSA4LCBzdGF0dXMgPSBcImluZm9cIixcbiAgICAgICAgICAgICAgICAgIHRhYmxlT3V0cHV0KFwib3V0X2RhdGFfUXVpel9UYWJsZVwiKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgZmx1aWRSb3coXG4gICAgICAgICAgICAgICAgYm94KFxuICAgICAgICAgICAgICAgICAgdGl0bGUgPSBcIlJpZ2h0IHZzLiBXcm9uZ1wiLFxuICAgICAgICAgICAgICAgICAgd2lkdGggPSA2LCBzdGF0dXMgPSBcImluZm9cIixcbiAgICAgICAgICAgICAgICAgIHBsb3RseU91dHB1dChcIm91dF9kYXRhX1F1aXpfUGllXCIpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIHRpdGxlID0gXCJRdWl6ICVcIixcbiAgICAgICAgICAgICAgICAgIHdpZHRoID0gNixcbiAgICAgICAgICAgICAgICAgIHZhbHVlQm94T3V0cHV0KFwib3V0X2RhdGFfUXVpel9WQlwiKVxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICkpXG4gICAgKVxuICApXG4pXG5cbnNlcnZlciA8LSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0KSB7XG4gIHNldC5zZWVkKDEyMilcbiAgaGlzdGRhdGEgPC0gcm5vcm0oNTAwKVxuICBcbiAgXG4gIG91dHB1dCRIaXN0b2dyYW0gPC0gcmVuZGVyUGxvdCh7XG4gICAgZGF0YSA8LSBoaXN0ZGF0YVtzZXFfbGVuKGlucHV0JHNsaWRlcildXG4gICAgaGlzdChkYXRhKVxuICB9KVxuICBcblxuICBcbiMjI1xuIyBSaWdodCBIYW5kIE1vdmVtZW50XG4jIyNcbiAgXG4gIFxuICAjb3V0cHV0dGluZyB0aGUgbWV0YSBkYXRhIG9mIHNlbGVjdGVkIGZpbGVcbiAgb3V0cHV0JG91dF9kYXRhX2YxIDwtIHJlbmRlclRhYmxlKHtcbiAgICAgIGlmKGlzLm51bGwoaW5wdXQkZGF0YV9mKSkge3JldHVybigpfVxuICAgICAgZWxzZXtcbiAgICAgICAgaW5wdXQkZGF0YV9mXG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgICBcbiAgIyBNYWRlIGEgRGF0YVRhYmxlIHRvIGJldHRlciB2aXN1YWxpemUgZGF0YVxuICAgIGRhdGFfZmlsZSA8LSByZWFjdGl2ZSh7XG4gICAgICAgICAgICBpZihpcy5udWxsKGlucHV0JGRhdGFfZikpIHtyZXR1cm4oKX1cbiAgICAgIGVsc2V7XG4gICAgICAgIGZpbGVfc3BlYyA8LSBpbnB1dCRkYXRhX2ZcblxuICAgICAgICAjSWYgaGVhZGVyID0gVCwgaXQgd2lsbCBza2lwIHRoZSBmaXJzdCBsaW5lIHRvIG5vdCBpbmNsdWRlIHdvcmRzIGluIHRoZSBsaXN0XG4gICAgICAgICNLZWVwIGl0IEYgc2luY2UgdGhlcmUgYXJlIG5vIGhlYWRlcnMgb24gdGhlIGRhdGEgY29sbGVjdGVkXG4gICAgICAgICNzZXAgd2lsbCBzdGF5IFwiLFwiIHNpbmNlIEkgb25seSBoYXZlIC5jc3YgZmlsZXNcbiAgICAgICAgYWE8LSByZWFkLnRhYmxlKGZpbGVfc3BlYyRkYXRhcGF0aCwgaGVhZGVyID0gRiwgc2VwID0gXCIsXCIpXG4gICAgICAgIFxuICAgICAgICAjQ2xlYW5pbmcgdGhlIHJhbmRvbSBPdXRsaWVycyBmcm9tIHRoZSBkYXRhIHNldCBhbmQgcmVuYW1pbmcgZm9yIHJlYWRhYmlsaXR5XG4gICAgICAgIFxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjFcIl0gPC0gXCJUaW1lXCJcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlYyXCJdIDwtIFwiWF9Qb3NcIlxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjNcIl0gPC0gXCJZX1Bvc1wiXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWNFwiXSA8LSBcIlpfUG9zXCJcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlY1XCJdIDwtIFwiWF9Sb3RcIlxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjZcIl0gPC0gXCJZX1JvdFwiXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWN1wiXSA8LSBcIlpfUm90XCJcbiAgICAgICAgXG4gICAgICAgIGFhIDwtIHN1YnNldChhYSwgWV9Qb3MgPiAwKVxuICAgICAgICBcbiAgICAgICAgYWEgPC0gZGF0YXRhYmxlKGFhLCBvcHRpb25zID0gbGlzdChzY3JvbGxYID0gVCwgc2Nyb2xsWSA9IFwiMjUwcHhcIikpXG4gICAgICAgIHJldHVybihhYSlcbiAgICAgIH1cbiAgICB9KVxuICAgIFxuICAgICMzRCBwbG90IFRlc3RpbmdcbiAgICBwbG90SW4zRCA8LSByZWFjdGl2ZSh7XG4gICAgICAgICAgICBpZihpcy5udWxsKGlucHV0JGRhdGFfZikpIHtyZXR1cm4oKX1cbiAgICAgIGVsc2V7XG4gICAgICAgIGZpbGVfc3BlYyA8LSBpbnB1dCRkYXRhX2ZcblxuICAgICAgICBhYTwtIHJlYWQudGFibGUoZmlsZV9zcGVjJGRhdGFwYXRoLCBoZWFkZXIgPSBGLCBzZXAgPSBcIixcIilcbiAgICAgICAgXG4gICAgICAgICNDbGVhbmluZyB0aGUgcmFuZG9tIE91dGxpZXJzIGZyb20gdGhlIGRhdGEgc2V0XG4gICAgICAgIFxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjFcIl0gPC0gXCJUaW1lXCJcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlYyXCJdIDwtIFwiWF9Qb3NcIlxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjNcIl0gPC0gXCJZX1Bvc1wiXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWNFwiXSA8LSBcIlpfUG9zXCJcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlY1XCJdIDwtIFwiWF9Sb3RcIlxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjZcIl0gPC0gXCJZX1JvdFwiXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWN1wiXSA8LSBcIlpfUm90XCJcbiAgICAgICAgXG4gICAgICAgIGFhIDwtIHN1YnNldChhYSwgWV9Qb3MgPiAwKVxuICAgICAgICAgIFxuICAgICAgICBcbiAgICAgICAgcGxvdF9seShhYSwgeCA9IGFhWywyXSwgeSA9IGFhWywzXSwgeiA9IGFhWyw0XSkgJT4lXG4gICAgICAgICAgYWRkX21hcmtlcnMoY29sb3IgPSBhYVssMV0sIHRpdGxlID0gXCJUaW1lXCIpXG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgICBcbiAgICAjRG9pbmcgdGhlIE1lYW4gVGFibGVcbiAgICByZXR1cm5NZWFuIDwtIHJlYWN0aXZlKHtcbiAgICAgICAgICAgIGlmKGlzLm51bGwoaW5wdXQkZGF0YV9mKSkge3JldHVybigpfVxuICAgICAgZWxzZXtcbiAgICAgICAgZmlsZV9zcGVjIDwtIGlucHV0JGRhdGFfZlxuXG4gICAgICAgIGFhPC0gcmVhZC50YWJsZShmaWxlX3NwZWMkZGF0YXBhdGgsIGhlYWRlciA9IEYsIHNlcCA9IFwiLFwiKVxuICAgICAgICBcbiAgICAgICAgI0NsZWFuaW5nIHRoZSByYW5kb20gT3V0bGllcnMgZnJvbSB0aGUgZGF0YSBzZXRcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBhYSA8LSBzdWJzZXQoYWEsIFYzID4gMClcbiAgICAgICAgXG4gICAgICAgIGNvbE5hbWVzIDwtIGMoXCJYX01lYW5cIiwgXCJZX01lYW5cIiwgXCJaX01lYW5cIilcbiAgICAgICAgZmlsbGluZ3MgPC0gYyhtZWFuKGFhWywyXSksbWVhbihhYVssM10pLG1lYW4oYWFbLDRdKSlcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBtZWFuTWF0cml4IDwtIHJiaW5kKGNvbE5hbWVzLCBmaWxsaW5ncylcbiAgICAgICAgXG4gICAgICAgIG5hbWVzKG1lYW5NYXRyaXgpW25hbWVzKG1lYW5NYXRyaXgpID09IFwiVjFcIl0gPC0gXCJYX01lYW5cIlxuICAgICAgICBuYW1lcyhtZWFuTWF0cml4KVtuYW1lcyhtZWFuTWF0cml4KSA9PSBcIlYyXCJdIDwtIFwiWV9NZWFuXCJcbiAgICAgICAgbmFtZXMobWVhbk1hdHJpeClbbmFtZXMobWVhbk1hdHJpeCkgPT0gXCJWM1wiXSA8LSBcIlpfTWVhblwiXG4gICAgICAgIFxuICAgICAgICByZXR1cm4obWVhbk1hdHJpeClcbiAgICAgIH1cbiAgICB9KVxuICAgIFxuICAgICNEb2luZyB0aGUgU3RhbmRhcmQgRGV2aWF0aW9uIFRhYmxlXG4gICAgcmV0dXJuU1REZXYgPC0gcmVhY3RpdmUoe1xuICAgICAgICAgICAgaWYoaXMubnVsbChpbnB1dCRkYXRhX2YpKSB7cmV0dXJuKCl9XG4gICAgICBlbHNle1xuICAgICAgICBmaWxlX3NwZWMgPC0gaW5wdXQkZGF0YV9mXG5cbiAgICAgICAgYWE8LSByZWFkLnRhYmxlKGZpbGVfc3BlYyRkYXRhcGF0aCwgaGVhZGVyID0gRiwgc2VwID0gXCIsXCIpXG4gICAgICAgIFxuICAgICAgICAjQ2xlYW5pbmcgdGhlIHJhbmRvbSBPdXRsaWVycyBmcm9tIHRoZSBkYXRhIHNldFxuICAgICAgICBcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlYxXCJdIDwtIFwiVGltZVwiXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWMlwiXSA8LSBcIlhfUG9zXCJcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlYzXCJdIDwtIFwiWV9Qb3NcIlxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjRcIl0gPC0gXCJaX1Bvc1wiXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWNVwiXSA8LSBcIlhfUm90XCJcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlY2XCJdIDwtIFwiWV9Sb3RcIlxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjdcIl0gPC0gXCJaX1JvdFwiXG4gICAgICAgIFxuICAgICAgICBhYSA8LSBzdWJzZXQoYWEsIFlfUG9zID4gMClcbiAgICAgICAgXG4gICAgICAgIGNvbE5hbWVzIDwtIGMoXCJYX1NURFwiLCBcIllfU1REXCIsIFwiWl9TVERcIilcbiAgICAgICAgZmlsbGluZ3MgPC0gYyhzZChhYVssMl0pLHNkKGFhWywzXSksc2QoYWFbLDRdKSlcbiAgICAgICAgXG4gICAgICAgIHN0ZE1hdHJpeCA8LSByYmluZChjb2xOYW1lcywgZmlsbGluZ3MpXG4gICAgICAgIFxuICAgICAgICByZXR1cm4oc3RkTWF0cml4KVxuICAgICAgfVxuICAgIH0pXG4gICAgXG4gICAgI0RvaW5nIHRoZSBWYXJpYW5jZSBUYWJsZVxuICAgIHJldHVyblZhcmlhbmNlIDwtIHJlYWN0aXZlKHtcbiAgICAgICAgICAgIGlmKGlzLm51bGwoaW5wdXQkZGF0YV9mKSkge3JldHVybigpfVxuICAgICAgZWxzZXtcbiAgICAgICAgZmlsZV9zcGVjIDwtIGlucHV0JGRhdGFfZlxuXG4gICAgICAgIGFhPC0gcmVhZC50YWJsZShmaWxlX3NwZWMkZGF0YXBhdGgsIGhlYWRlciA9IEYsIHNlcCA9IFwiLFwiKVxuICAgICAgICBcbiAgICAgICAgI0NsZWFuaW5nIHRoZSByYW5kb20gT3V0bGllcnMgZnJvbSB0aGUgZGF0YSBzZXRcbiAgICAgICAgXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWMVwiXSA8LSBcIlRpbWVcIlxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjJcIl0gPC0gXCJYX1Bvc1wiXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWM1wiXSA8LSBcIllfUG9zXCJcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlY0XCJdIDwtIFwiWl9Qb3NcIlxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjVcIl0gPC0gXCJYX1JvdFwiXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWNlwiXSA8LSBcIllfUm90XCJcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlY3XCJdIDwtIFwiWl9Sb3RcIlxuICAgICAgICBcbiAgICAgICAgYWEgPC0gc3Vic2V0KGFhLCBZX1BvcyA+IDApXG4gICAgICAgIFxuICAgICAgICBjb2xOYW1lcyA8LSBjKFwiWF9WYXJcIiwgXCJZX1ZhclwiLCBcIlpfVmFyXCIpXG4gICAgICAgIGZpbGxpbmdzIDwtIGModmFyKGFhWywyXSksdmFyKGFhWywzXSksdmFyKGFhWyw0XSkpXG4gICAgICAgIFxuICAgICAgICB2YXJNYXRyaXggPC0gcmJpbmQoY29sTmFtZXMsIGZpbGxpbmdzKVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuKHZhck1hdHJpeClcbiAgICAgIH1cbiAgICB9KVxuICAgIFxuIyMjXG4jIEhNRFxuIyMjXG4gICAgXG4gICAgXG4gICAgI291dHB1dHRpbmcgdGhlIG1ldGEgZGF0YSBvZiBzZWxlY3RlZCBmaWxlXG4gICAgb3V0cHV0JG91dF9kYXRhX0hNRF9NZXRhIDwtIHJlbmRlclRhYmxlKHtcbiAgICAgIGlmIChpcy5udWxsKGlucHV0JGRhdGFfSE1EKSkge1xuICAgICAgICByZXR1cm4oKVxuICAgICAgfVxuICAgICAgZWxzZXtcbiAgICAgICAgaW5wdXQkZGF0YV9ITURcbiAgICAgIH1cbiAgICB9KVxuICAgICNEb2luZyB0aGUgTWVhbiBUYWJsZSBmb3IgSE1EXG4gICAgcmV0dXJuTWVhbl9ITUQgPC0gcmVhY3RpdmUoe1xuICAgICAgICAgICAgaWYoaXMubnVsbChpbnB1dCRkYXRhX0hNRCkpIHtyZXR1cm4oKX1cbiAgICAgIGVsc2V7XG4gICAgICAgIGZpbGVfc3BlYyA8LSBpbnB1dCRkYXRhX0hNRFxuXG4gICAgICAgIGFhPC0gcmVhZC50YWJsZShmaWxlX3NwZWMkZGF0YXBhdGgsIGhlYWRlciA9IEYsIHNlcCA9IFwiLFwiKVxuICAgICAgICBcbiAgICAgICAgI0NsZWFuaW5nIHRoZSByYW5kb20gT3V0bGllcnMgZnJvbSB0aGUgZGF0YSBzZXRcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBjb2xOYW1lcyA8LSBjKFwiWF9NZWFuXCIsIFwiWV9NZWFuXCIsIFwiWl9NZWFuXCIpXG4gICAgICAgIGZpbGxpbmdzIDwtIGMobWVhbihhYVssMl0pLG1lYW4oYWFbLDNdKSxtZWFuKGFhWyw0XSkpXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgbWVhbk1hdHJpeCA8LSByYmluZChjb2xOYW1lcywgZmlsbGluZ3MpXG4gICAgICAgIFxuICAgICAgICBuYW1lcyhtZWFuTWF0cml4KVtuYW1lcyhtZWFuTWF0cml4KSA9PSBcIlYxXCJdIDwtIFwiWF9NZWFuXCJcbiAgICAgICAgbmFtZXMobWVhbk1hdHJpeClbbmFtZXMobWVhbk1hdHJpeCkgPT0gXCJWMlwiXSA8LSBcIllfTWVhblwiXG4gICAgICAgIG5hbWVzKG1lYW5NYXRyaXgpW25hbWVzKG1lYW5NYXRyaXgpID09IFwiVjNcIl0gPC0gXCJaX01lYW5cIlxuICAgICAgICBcbiAgICAgICAgcmV0dXJuKG1lYW5NYXRyaXgpXG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgICAjRG9pbmcgdGhlIFN0YW5kYXJkIERldmlhdGlvbiBUYWJsZVxuICAgIHJldHVyblNURGV2X0hNRCA8LSByZWFjdGl2ZSh7XG4gICAgICAgICAgICBpZihpcy5udWxsKGlucHV0JGRhdGFfSE1EKSkge3JldHVybigpfVxuICAgICAgZWxzZXtcbiAgICAgICAgZmlsZV9zcGVjIDwtIGlucHV0JGRhdGFfSE1EXG5cbiAgICAgICAgYWE8LSByZWFkLnRhYmxlKGZpbGVfc3BlYyRkYXRhcGF0aCwgaGVhZGVyID0gRiwgc2VwID0gXCIsXCIpXG4gICAgICAgIFxuICAgICAgICAjQ2xlYW5pbmcgdGhlIHJhbmRvbSBPdXRsaWVycyBmcm9tIHRoZSBkYXRhIHNldFxuICAgICAgICBcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlYxXCJdIDwtIFwiVGltZVwiXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWMlwiXSA8LSBcIlhfUG9zXCJcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlYzXCJdIDwtIFwiWV9Qb3NcIlxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjRcIl0gPC0gXCJaX1Bvc1wiXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWNVwiXSA8LSBcIlhfUm90XCJcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlY2XCJdIDwtIFwiWV9Sb3RcIlxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjdcIl0gPC0gXCJaX1JvdFwiXG4gICAgICAgIFxuXG4gICAgICAgIGNvbE5hbWVzIDwtIGMoXCJYX1NURFwiLCBcIllfU1REXCIsIFwiWl9TVERcIilcbiAgICAgICAgZmlsbGluZ3MgPC0gYyhzZChhYVssMl0pLHNkKGFhWywzXSksc2QoYWFbLDRdKSlcbiAgICAgICAgXG4gICAgICAgIHN0ZE1hdHJpeCA8LSByYmluZChjb2xOYW1lcywgZmlsbGluZ3MpXG4gICAgICAgIFxuICAgICAgICByZXR1cm4oc3RkTWF0cml4KVxuICAgICAgfVxuICAgIH0pXG4gICAgXG4gICAgI0RvaW5nIHRoZSBWYXJpYW5jZSBUYWJsZVxuICAgIHJldHVyblZhcmlhbmNlX0hNRCA8LSByZWFjdGl2ZSh7XG4gICAgICAgICAgICBpZihpcy5udWxsKGlucHV0JGRhdGFfSE1EKSkge3JldHVybigpfVxuICAgICAgZWxzZXtcbiAgICAgICAgZmlsZV9zcGVjIDwtIGlucHV0JGRhdGFfSE1EXG5cbiAgICAgICAgYWE8LSByZWFkLnRhYmxlKGZpbGVfc3BlYyRkYXRhcGF0aCwgaGVhZGVyID0gRiwgc2VwID0gXCIsXCIpXG4gICAgICAgIFxuICAgICAgICAjQ2xlYW5pbmcgdGhlIHJhbmRvbSBPdXRsaWVycyBmcm9tIHRoZSBkYXRhIHNldFxuICAgICAgICBcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlYxXCJdIDwtIFwiVGltZVwiXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWMlwiXSA8LSBcIlhfUG9zXCJcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlYzXCJdIDwtIFwiWV9Qb3NcIlxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjRcIl0gPC0gXCJaX1Bvc1wiXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWNVwiXSA8LSBcIlhfUm90XCJcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlY2XCJdIDwtIFwiWV9Sb3RcIlxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjdcIl0gPC0gXCJaX1JvdFwiXG4gICAgICAgIFxuXG4gICAgICAgIGNvbE5hbWVzIDwtIGMoXCJYX1ZhclwiLCBcIllfVmFyXCIsIFwiWl9WYXJcIilcbiAgICAgICAgZmlsbGluZ3MgPC0gYyh2YXIoYWFbLDJdKSx2YXIoYWFbLDNdKSx2YXIoYWFbLDRdKSlcbiAgICAgICAgXG4gICAgICAgIHZhck1hdHJpeCA8LSByYmluZChjb2xOYW1lcywgZmlsbGluZ3MpXG4gICAgICAgIFxuICAgICAgICByZXR1cm4odmFyTWF0cml4KVxuICAgICAgfVxuICAgIH0pXG4gICAgXG4gICAgIyBNYWRlIGEgRGF0YVRhYmxlIHRvIGJldHRlciB2aXN1YWxpemUgZGF0YVxuICAgIGRhdGFfZmlsZV9ITUQgPC0gcmVhY3RpdmUoe1xuICAgICAgICAgICAgaWYoaXMubnVsbChpbnB1dCRkYXRhX0hNRCkpIHtyZXR1cm4oKX1cbiAgICAgIGVsc2V7XG4gICAgICAgIGZpbGVfc3BlYyA8LSBpbnB1dCRkYXRhX0hNRFxuXG4gICAgICAgICNJZiBoZWFkZXIgPSBULCBpdCB3aWxsIHNraXAgdGhlIGZpcnN0IGxpbmUgdG8gbm90IGluY2x1ZGUgd29yZHMgaW4gdGhlIGxpc3RcbiAgICAgICAgI0tlZXAgaXQgRiBzaW5jZSB0aGVyZSBhcmUgbm8gaGVhZGVycyBvbiB0aGUgZGF0YSBjb2xsZWN0ZWRcbiAgICAgICAgI3NlcCB3aWxsIHN0YXkgXCIsXCIgc2luY2UgSSBvbmx5IGhhdmUgLmNzdiBmaWxlc1xuICAgICAgICBhYTwtIHJlYWQudGFibGUoZmlsZV9zcGVjJGRhdGFwYXRoLCBoZWFkZXIgPSBGLCBzZXAgPSBcIixcIilcbiAgICAgICAgXG4gICAgICAgICNDbGVhbmluZyB0aGUgcmFuZG9tIE91dGxpZXJzIGZyb20gdGhlIGRhdGEgc2V0IGFuZCByZW5hbWluZyBmb3IgcmVhZGFiaWxpdHlcbiAgICAgICAgXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWMVwiXSA8LSBcIlRpbWVcIlxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjJcIl0gPC0gXCJYX1Bvc1wiXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWM1wiXSA8LSBcIllfUG9zXCJcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlY0XCJdIDwtIFwiWl9Qb3NcIlxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjVcIl0gPC0gXCJYX1JvdFwiXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWNlwiXSA8LSBcIllfUm90XCJcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlY3XCJdIDwtIFwiWl9Sb3RcIlxuICAgICAgICBcblxuICAgICAgICBhYSA8LSBkYXRhdGFibGUoYWEsIG9wdGlvbnMgPSBsaXN0KHNjcm9sbFggPSBULCBzY3JvbGxZID0gXCIyNTBweFwiKSlcbiAgICAgICAgcmV0dXJuKGFhKVxuICAgICAgICAjcmV0dXJuKGRhdGF0YWJsZShhYSwgb3B0aW9ucyA9IGxpc3Qoc2Nyb2xsWCA9IFQsIHNjcm9sbFkgPSBcIjI1MHB4XCIpKSlcbiAgICAgIH1cbiAgICB9KVxuICAgIFxuICAgIFxuICAgICMzRCBwbG90dGluZyBIZWFkIE1vdW50ZWQgRGlzcGxheVxuICAgIHBsb3RJbjNEX0hNRCA8LSByZWFjdGl2ZSh7XG4gICAgICAgICAgICBpZihpcy5udWxsKGlucHV0JGRhdGFfSE1EKSkge3JldHVybigpfVxuICAgICAgZWxzZXtcbiAgICAgICAgZmlsZV9zcGVjIDwtIGlucHV0JGRhdGFfSE1EXG5cbiAgICAgICAgYWE8LSByZWFkLnRhYmxlKGZpbGVfc3BlYyRkYXRhcGF0aCwgaGVhZGVyID0gRiwgc2VwID0gXCIsXCIpXG4gICAgICAgIFxuICAgICAgICAjQ2xlYW5pbmcgdGhlIHJhbmRvbSBPdXRsaWVycyBmcm9tIHRoZSBkYXRhIHNldFxuXG4gICAgICAgIHBsb3RfbHkoYWEsIHggPSBhYVssMl0sIHkgPSBhYVssM10sIHogPSBhYVssNF0pICU+JVxuICAgICAgICAgIGFkZF9tYXJrZXJzKGNvbG9yID0gYWFbLDFdLCB0aXRsZSA9IFwiVGltZVwiKVxuICAgICAgfVxuICAgIH0pXG4gICAgXG4jIyNcbiMgTGVmdCBIYW5kXG4jIyNcbiAgICBcbiAgXG4gICNvdXRwdXR0aW5nIHRoZSBtZXRhIGRhdGEgb2Ygc2VsZWN0ZWQgZmlsZVxuICBvdXRwdXQkb3V0X2RhdGFfTGVmdF9NZXRhIDwtIHJlbmRlclRhYmxlKHtcbiAgICAgIGlmKGlzLm51bGwoaW5wdXQkZGF0YV9MZWZ0KSkge3JldHVybigpfVxuICAgICAgZWxzZXtcbiAgICAgICAgaW5wdXQkZGF0YV9MZWZ0XG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgICBcbiAgIyBNYWRlIGEgRGF0YVRhYmxlIHRvIGJldHRlciB2aXN1YWxpemUgZGF0YVxuICAgIGRhdGFfZmlsZV9MZWZ0IDwtIHJlYWN0aXZlKHtcbiAgICAgICAgICAgIGlmKGlzLm51bGwoaW5wdXQkZGF0YV9MZWZ0KSkge3JldHVybigpfVxuICAgICAgZWxzZXtcbiAgICAgICAgZmlsZV9zcGVjIDwtIGlucHV0JGRhdGFfTGVmdFxuXG4gICAgICAgICNJZiBoZWFkZXIgPSBULCBpdCB3aWxsIHNraXAgdGhlIGZpcnN0IGxpbmUgdG8gbm90IGluY2x1ZGUgd29yZHMgaW4gdGhlIGxpc3RcbiAgICAgICAgI0tlZXAgaXQgRiBzaW5jZSB0aGVyZSBhcmUgbm8gaGVhZGVycyBvbiB0aGUgZGF0YSBjb2xsZWN0ZWRcbiAgICAgICAgI3NlcCB3aWxsIHN0YXkgXCIsXCIgc2luY2UgSSBvbmx5IGhhdmUgLmNzdiBmaWxlc1xuICAgICAgICBhYTwtIHJlYWQudGFibGUoZmlsZV9zcGVjJGRhdGFwYXRoLCBoZWFkZXIgPSBGLCBzZXAgPSBcIixcIilcbiAgICAgICAgXG4gICAgICAgICNDbGVhbmluZyB0aGUgcmFuZG9tIE91dGxpZXJzIGZyb20gdGhlIGRhdGEgc2V0IGFuZCByZW5hbWluZyBmb3IgcmVhZGFiaWxpdHlcbiAgICAgICAgXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWMVwiXSA8LSBcIlRpbWVcIlxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjJcIl0gPC0gXCJYX1Bvc1wiXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWM1wiXSA8LSBcIllfUG9zXCJcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlY0XCJdIDwtIFwiWl9Qb3NcIlxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjVcIl0gPC0gXCJYX1JvdFwiXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWNlwiXSA8LSBcIllfUm90XCJcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlY3XCJdIDwtIFwiWl9Sb3RcIlxuICAgICAgICBcbiAgICAgICAgYWEgPC0gc3Vic2V0KGFhLCBZX1BvcyA+IDUuOTUpXG4gICAgICAgIFxuICAgICAgICBhYSA8LSBkYXRhdGFibGUoYWEsIG9wdGlvbnMgPSBsaXN0KHNjcm9sbFggPSBULCBzY3JvbGxZID0gXCIyNTBweFwiKSlcbiAgICAgICAgcmV0dXJuKGFhKVxuICAgICAgfVxuICAgIH0pXG4gICAgXG4gICAgIzNEIHBsb3QgVGVzdGluZ1xuICAgIHBsb3RJbjNEX0xlZnQgPC0gcmVhY3RpdmUoe1xuICAgICAgICAgICAgaWYoaXMubnVsbChpbnB1dCRkYXRhX0xlZnQpKSB7cmV0dXJuKCl9XG4gICAgICBlbHNle1xuICAgICAgICBmaWxlX3NwZWMgPC0gaW5wdXQkZGF0YV9MZWZ0XG5cbiAgICAgICAgYWE8LSByZWFkLnRhYmxlKGZpbGVfc3BlYyRkYXRhcGF0aCwgaGVhZGVyID0gRiwgc2VwID0gXCIsXCIpXG4gICAgICAgIFxuICAgICAgICAjQ2xlYW5pbmcgdGhlIHJhbmRvbSBPdXRsaWVycyBmcm9tIHRoZSBkYXRhIHNldFxuICAgICAgICBcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlYxXCJdIDwtIFwiVGltZVwiXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWMlwiXSA8LSBcIlhfUG9zXCJcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlYzXCJdIDwtIFwiWV9Qb3NcIlxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjRcIl0gPC0gXCJaX1Bvc1wiXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWNVwiXSA8LSBcIlhfUm90XCJcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlY2XCJdIDwtIFwiWV9Sb3RcIlxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjdcIl0gPC0gXCJaX1JvdFwiXG4gICAgICAgIFxuICAgICAgICBhYSA8LSBzdWJzZXQoYWEsIFlfUG9zID4gNS45NSlcbiAgICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIHBsb3RfbHkoYWEsIHggPSBhYVssMl0sIHkgPSBhYVssM10sIHogPSBhYVssNF0pICU+JVxuICAgICAgICAgIGFkZF9tYXJrZXJzKGNvbG9yID0gYWFbLDFdLCB0aXRsZSA9IFwiVGltZVwiKVxuICAgICAgfVxuICAgIH0pXG4gICAgXG4gICAgXG4gICAgI0RvaW5nIHRoZSBNZWFuIFRhYmxlXG4gICAgcmV0dXJuTWVhbl9MZWZ0IDwtIHJlYWN0aXZlKHtcbiAgICAgICAgICAgIGlmKGlzLm51bGwoaW5wdXQkZGF0YV9MZWZ0KSkge3JldHVybigpfVxuICAgICAgZWxzZXtcbiAgICAgICAgZmlsZV9zcGVjIDwtIGlucHV0JGRhdGFfTGVmdFxuXG4gICAgICAgIGFhPC0gcmVhZC50YWJsZShmaWxlX3NwZWMkZGF0YXBhdGgsIGhlYWRlciA9IEYsIHNlcCA9IFwiLFwiKVxuICAgICAgICBcbiAgICAgICAgI0NsZWFuaW5nIHRoZSByYW5kb20gT3V0bGllcnMgZnJvbSB0aGUgZGF0YSBzZXRcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBhYSA8LSBzdWJzZXQoYWEsIFYzID4gNS45NSlcbiAgICAgICAgXG4gICAgICAgIGNvbE5hbWVzIDwtIGMoXCJYX01lYW5cIiwgXCJZX01lYW5cIiwgXCJaX01lYW5cIilcbiAgICAgICAgZmlsbGluZ3MgPC0gYyhtZWFuKGFhWywyXSksbWVhbihhYVssM10pLG1lYW4oYWFbLDRdKSlcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBtZWFuTWF0cml4IDwtIHJiaW5kKGNvbE5hbWVzLCBmaWxsaW5ncylcbiAgICAgICAgXG4gICAgICAgIG5hbWVzKG1lYW5NYXRyaXgpW25hbWVzKG1lYW5NYXRyaXgpID09IFwiVjFcIl0gPC0gXCJYX01lYW5cIlxuICAgICAgICBuYW1lcyhtZWFuTWF0cml4KVtuYW1lcyhtZWFuTWF0cml4KSA9PSBcIlYyXCJdIDwtIFwiWV9NZWFuXCJcbiAgICAgICAgbmFtZXMobWVhbk1hdHJpeClbbmFtZXMobWVhbk1hdHJpeCkgPT0gXCJWM1wiXSA8LSBcIlpfTWVhblwiXG4gICAgICAgIFxuICAgICAgICByZXR1cm4obWVhbk1hdHJpeClcbiAgICAgIH1cbiAgICB9KVxuICAgIFxuICAgICNEb2luZyB0aGUgU3RhbmRhcmQgRGV2aWF0aW9uIFRhYmxlXG4gICAgcmV0dXJuU1REZXZfTGVmdCA8LSByZWFjdGl2ZSh7XG4gICAgICAgICAgICBpZihpcy5udWxsKGlucHV0JGRhdGFfTGVmdCkpIHtyZXR1cm4oKX1cbiAgICAgIGVsc2V7XG4gICAgICAgIGZpbGVfc3BlYyA8LSBpbnB1dCRkYXRhX0xlZnRcblxuICAgICAgICBhYTwtIHJlYWQudGFibGUoZmlsZV9zcGVjJGRhdGFwYXRoLCBoZWFkZXIgPSBGLCBzZXAgPSBcIixcIilcbiAgICAgICAgXG4gICAgICAgICNDbGVhbmluZyB0aGUgcmFuZG9tIE91dGxpZXJzIGZyb20gdGhlIGRhdGEgc2V0XG4gICAgICAgIFxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjFcIl0gPC0gXCJUaW1lXCJcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlYyXCJdIDwtIFwiWF9Qb3NcIlxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjNcIl0gPC0gXCJZX1Bvc1wiXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWNFwiXSA8LSBcIlpfUG9zXCJcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlY1XCJdIDwtIFwiWF9Sb3RcIlxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjZcIl0gPC0gXCJZX1JvdFwiXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWN1wiXSA8LSBcIlpfUm90XCJcbiAgICAgICAgXG4gICAgICAgIGFhIDwtIHN1YnNldChhYSwgWV9Qb3MgPiAwKVxuICAgICAgICBcbiAgICAgICAgY29sTmFtZXMgPC0gYyhcIlhfU1REXCIsIFwiWV9TVERcIiwgXCJaX1NURFwiKVxuICAgICAgICBmaWxsaW5ncyA8LSBjKHNkKGFhWywyXSksc2QoYWFbLDNdKSxzZChhYVssNF0pKVxuICAgICAgICBcbiAgICAgICAgc3RkTWF0cml4IDwtIHJiaW5kKGNvbE5hbWVzLCBmaWxsaW5ncylcbiAgICAgICAgXG4gICAgICAgIHJldHVybihzdGRNYXRyaXgpXG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgICAjRG9pbmcgdGhlIFZhcmlhbmNlIFRhYmxlXG4gICAgcmV0dXJuVmFyaWFuY2VfTGVmdCA8LSByZWFjdGl2ZSh7XG4gICAgICAgICAgICBpZihpcy5udWxsKGlucHV0JGRhdGFfTGVmdCkpIHtyZXR1cm4oKX1cbiAgICAgIGVsc2V7XG4gICAgICAgIGZpbGVfc3BlYyA8LSBpbnB1dCRkYXRhX0xlZnRcblxuICAgICAgICBhYTwtIHJlYWQudGFibGUoZmlsZV9zcGVjJGRhdGFwYXRoLCBoZWFkZXIgPSBGLCBzZXAgPSBcIixcIilcbiAgICAgICAgXG4gICAgICAgICNDbGVhbmluZyB0aGUgcmFuZG9tIE91dGxpZXJzIGZyb20gdGhlIGRhdGEgc2V0XG4gICAgICAgIFxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjFcIl0gPC0gXCJUaW1lXCJcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlYyXCJdIDwtIFwiWF9Qb3NcIlxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjNcIl0gPC0gXCJZX1Bvc1wiXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWNFwiXSA8LSBcIlpfUG9zXCJcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlY1XCJdIDwtIFwiWF9Sb3RcIlxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjZcIl0gPC0gXCJZX1JvdFwiXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWN1wiXSA8LSBcIlpfUm90XCJcbiAgICAgICAgXG4gICAgICAgIGFhIDwtIHN1YnNldChhYSwgWV9Qb3MgPiAwKVxuICAgICAgICBcbiAgICAgICAgY29sTmFtZXMgPC0gYyhcIlhfVmFyXCIsIFwiWV9WYXJcIiwgXCJaX1ZhclwiKVxuICAgICAgICBmaWxsaW5ncyA8LSBjKHZhcihhYVssMl0pLHZhcihhYVssM10pLHZhcihhYVssNF0pKVxuICAgICAgICBcbiAgICAgICAgdmFyTWF0cml4IDwtIHJiaW5kKGNvbE5hbWVzLCBmaWxsaW5ncylcbiAgICAgICAgXG4gICAgICAgIHJldHVybih2YXJNYXRyaXgpXG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgICBcbiMjI1xuIyBNZXRyaWNzXG4jIyNcbiAgICBcbiAgICAgICMgTWFkZSBhIERhdGFUYWJsZSB0byBiZXR0ZXIgdmlzdWFsaXplIGRhdGFcbiAgICBkYXRhX01ldHJpY3NfVGFibGUgPC0gcmVhY3RpdmUoe1xuICAgICAgICAgICAgaWYoaXMubnVsbChpbnB1dCRkYXRhX01ldHJpY3MpKSB7cmV0dXJuKCl9XG4gICAgICBlbHNle1xuICAgICAgICBmaWxlX3NwZWMgPC0gaW5wdXQkZGF0YV9NZXRyaWNzXG5cbiAgICAgICAgI0lmIGhlYWRlciA9IFQsIGl0IHdpbGwgc2tpcCB0aGUgZmlyc3QgbGluZSB0byBub3QgaW5jbHVkZSB3b3JkcyBpbiB0aGUgbGlzdFxuICAgICAgICAjS2VlcCBpdCBGIHNpbmNlIHRoZXJlIGFyZSBubyBoZWFkZXJzIG9uIHRoZSBkYXRhIGNvbGxlY3RlZFxuICAgICAgICAjc2VwIHdpbGwgc3RheSBcIixcIiBzaW5jZSBJIG9ubHkgaGF2ZSAuY3N2IGZpbGVzXG4gICAgICAgIGFhPC0gcmVhZC50YWJsZShmaWxlX3NwZWMkZGF0YXBhdGgsIGhlYWRlciA9IEYsIHNlcCA9IFwiLFwiKVxuICAgICAgICBcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlYxXCJdIDwtIFwiVGltZVwiXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWMlwiXSA8LSBcIk1ldHJpYyBOdW1iZXJcIlxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjNcIl0gPC0gXCJTY29yZVwiXG4gICAgICAgIFxuICAgICAgICByZXR1cm4oYWEpXG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgICBvdXRfZGF0YV9NZXRyaWNzX1dvcmtPblRhYmxlIDwtIHJlYWN0aXZlKHtcbiAgICAgICAgICAgIGlmKGlzLm51bGwoaW5wdXQkZGF0YV9NZXRyaWNzKSkge3JldHVybigpfVxuICAgICAgZWxzZXtcbiAgICAgICAgZmlsZV9zcGVjIDwtIGlucHV0JGRhdGFfTWV0cmljc1xuXG4gICAgICAgICNJZiBoZWFkZXIgPSBULCBpdCB3aWxsIHNraXAgdGhlIGZpcnN0IGxpbmUgdG8gbm90IGluY2x1ZGUgd29yZHMgaW4gdGhlIGxpc3RcbiAgICAgICAgI0tlZXAgaXQgRiBzaW5jZSB0aGVyZSBhcmUgbm8gaGVhZGVycyBvbiB0aGUgZGF0YSBjb2xsZWN0ZWRcbiAgICAgICAgI3NlcCB3aWxsIHN0YXkgXCIsXCIgc2luY2UgSSBvbmx5IGhhdmUgLmNzdiBmaWxlc1xuICAgICAgICBhYTwtIHJlYWQudGFibGUoZmlsZV9zcGVjJGRhdGFwYXRoLCBoZWFkZXIgPSBGLCBzZXAgPSBcIixcIilcbiAgICAgICAgXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWMVwiXSA8LSBcIlRpbWVcIlxuICAgICAgICBuYW1lcyhhYSlbbmFtZXMoYWEpID09IFwiVjJcIl0gPC0gXCJNZXRyaWMgTnVtYmVyXCJcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlYzXCJdIDwtIFwiU2NvcmVcIlxuICAgICAgICBcbiAgICAgICAgV08gPC0gYygpXG4gICAgICAgIFxuICAgICAgICBmb3IgKG51bSBpbiAxOm5yb3coYWEpKSB7XG4gICAgICAgICAgaWYoYWFbbnVtLDNdIDwgNSl7XG4gICAgICAgICAgICBXTyA8LSBhYVtudW0sXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuKFdPKVxuICAgICAgfVxuICAgIH0pXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4jIyNcbiMgUXVpelxuIyMjXG4gICAgXG4gICAgICAjIE1hZGUgYSBEYXRhVGFibGUgdG8gYmV0dGVyIHZpc3VhbGl6ZSBkYXRhXG4gICAgZGF0YV9RdWl6X1RhYmxlIDwtIHJlYWN0aXZlKHtcbiAgICAgICAgICAgIGlmKGlzLm51bGwoaW5wdXQkZGF0YV9RdWl6KSkge3JldHVybigpfVxuICAgICAgZWxzZXtcbiAgICAgICAgZmlsZV9zcGVjIDwtIGlucHV0JGRhdGFfUXVpelxuXG4gICAgICAgICNJZiBoZWFkZXIgPSBULCBpdCB3aWxsIHNraXAgdGhlIGZpcnN0IGxpbmUgdG8gbm90IGluY2x1ZGUgd29yZHMgaW4gdGhlIGxpc3RcbiAgICAgICAgI0tlZXAgaXQgRiBzaW5jZSB0aGVyZSBhcmUgbm8gaGVhZGVycyBvbiB0aGUgZGF0YSBjb2xsZWN0ZWRcbiAgICAgICAgI3NlcCB3aWxsIHN0YXkgXCIsXCIgc2luY2UgSSBvbmx5IGhhdmUgLmNzdiBmaWxlc1xuICAgICAgICBhYTwtIHJlYWQudGFibGUoZmlsZV9zcGVjJGRhdGFwYXRoLCBoZWFkZXIgPSBGLCBzZXAgPSBcIixcIilcbiAgICAgICAgXG4gICAgICAgIG5hbWVzKGFhKVtuYW1lcyhhYSkgPT0gXCJWMVwiXSA8LSBcIlN0ZXAgTnVtYmVyXCJcbiAgICAgICAgbmFtZXMoYWEpW25hbWVzKGFhKSA9PSBcIlYyXCJdIDwtIFwiQ29ycmVjdCBvciBJbmNvcnJlY3RcIlxuXG4gICAgICAgIHJldHVybihhYSlcbiAgICAgIH1cbiAgICB9KVxuICAgIFxuICAgIFxuICAgIFxuICAgICMzRCBwbG90IFRlc3RpbmdcbiAgICBRdWl6X1BpZUNoYXJ0IDwtIHJlYWN0aXZlKHtcbiAgICAgICAgICAgIGlmKGlzLm51bGwoaW5wdXQkZGF0YV9RdWl6KSkge3JldHVybigpfVxuICAgICAgZWxzZXtcbiAgICAgICAgZmlsZV9zcGVjIDwtIGlucHV0JGRhdGFfUXVpelxuXG4gICAgICAgIGFhPC0gcmVhZC50YWJsZShmaWxlX3NwZWMkZGF0YXBhdGgsIGhlYWRlciA9IEYsIHNlcCA9IFwiLFwiKVxuICAgICAgICBcbiAgICAgICAgI1Rha2Ugb3V0IHRoZSBmaW5hbCByb3cgdGhhdCBpcyB0aGUgJVxuICAgICAgICAgYWEgPC0gYWFbMToobnJvdyhhYSktMSksXVxuICAgICAgICAgQ2NvdW50ZXIgPC0gMFxuICAgICAgICAgV2NvdW50ZXIgPC0gMFxuICAgICAgICAgXG4gICAgICAgICBmb3IgKG51bSBpbiAxOihucm93KGFhKS0xKSkge1xuICAgICAgICAgICBpZihhYVtudW0sMl0gPT0gVCB8fCBhYVtudW0sMl0gPT0gMSB8fCBhYVtudW0sMl0gPT0gXCJUUlVFXCIpe1xuICAgICAgICAgICAgIENjb3VudGVyIDwtIENjb3VudGVyKzFcbiAgICAgICAgICAgfWVsc2UgaWYoYWFbbnVtLDJdID09IEYgfHwgYWFbbnVtLDJdID09IDAgfHwgYWFbbnVtLDJdID09IFwiRkFMU0VcIil7XG4gICAgICAgICAgICAgV2NvdW50ZXIgPC0gV2NvdW50ZXIgKyAxXG4gICAgICAgICAgIH1cbiAgICAgICAgIH0gXG4gICAgICAgICBDTmFtZXMgPC0gYyhcIkNvcnJlY3RcIiwgXCJJbmNvcnJlY3RcIilcbiAgICAgICAgIHNjb3JlcyA8LSBjKENjb3VudGVyLCBXY291bnRlcilcbiAgICAgICAgIFxuICAgICAgICAgXG4gICAgICAgICBmaWcgPC1cbiAgICAgICAgICAgcGxvdF9seShcbiAgICAgICAgICAgICB4ID0gQ05hbWVzLFxuICAgICAgICAgICAgIHkgPSBzY29yZXMsXG4gICAgICAgICAgICAgdHlwZSA9IFwiYmFyXCIsXG4gICAgICAgICAgICAgYmFzZSA9IDAsXG4gICAgICAgICAgICAgXG4gICAgICAgICAgICAgbmFtZSA9IGMoXCJDb3JyZWN0XCIsIFwiSW5jb3JyZWN0XCIpLGNvbG9yID0gQ05hbWVzLCBjb2xvcnMgPSBjKFwiIzBCNjYyM1wiLCBcIiM4MDAwMDBcIilcbiAgICAgICAgICAgKVxuICAgICAgICAgXG4gICAgICAgIHJldHVybihmaWcpXG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgICBRdWl6X1ZhbHVlQm94IDwtIHJlYWN0aXZlKHtcbiAgICAgIGlmKGlzLm51bGwoaW5wdXQkZGF0YV9RdWl6KSkge3JldHVybigpfVxuICAgICAgZWxzZXtcbiAgICAgICAgZmlsZV9zcGVjIDwtIGlucHV0JGRhdGFfUXVpelxuICAgICAgICBcbiAgICAgICAgUUI8LSByZWFkLnRhYmxlKGZpbGVfc3BlYyRkYXRhcGF0aCwgaGVhZGVyID0gRiwgc2VwID0gXCIsXCIpXG5cbiAgICAgICAgUUIgPC0gUUJbbnJvdyhRQiksMV1cbiAgICAgICAgXG4gICAgICAgIHJldHVybih2YWx1ZUJveChcbiAgICAgICAgICBRQiwgc3VidGl0bGUgPSBcIlF1aXogR3JhZGVcIiwgaWNvbiA9IGljb24oXCJwZXJjZW50XCIpLCBjb2xvciA9IFwidGVhbFwiXG4gICAgICAgICkpXG4gICAgICB9XG4gICAgICBcbiAgICB9KVxuICAgIFxuICAgIFxuICAgIFxuIyMjIyMjIyMjIyNcbiAgICBcbiAgICAjT3V0cHV0cyB0byBwbGFjZSBvbnRvIGFuIG91dHB1dCBvYmplY3RcbiAgICBcbiAgICAgIG91dHB1dCRvdXRfZGF0YV9mMiA8LSByZW5kZXJEYXRhVGFibGUoe1xuICAgICAgICAgICAgICAgICAgICBpZihpcy5udWxsKGlucHV0JGRhdGFfZikpIHtyZXR1cm4oKX1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICBkYXRhX2ZpbGUoKVxuICAgICAgICB9XG5cbiAgICAgIH0pXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICBvdXRwdXQkb3V0X2RhdGFfZjUgPC0gcmVuZGVyUGxvdGx5KHtcbiAgICAgICAgaWYoaXMubnVsbChpbnB1dCRkYXRhX2YpKSB7cmV0dXJuKCl9XG4gICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgcGxvdEluM0QoKVxuICAgICAgICAgICB9XG4gICAgICB9KVxuICAgICAgXG4gICAgICAgIFxuICAgICAgb3V0cHV0JG91dF9NZWFuX1Rlc3QgPC0gcmVuZGVyVGFibGUoe1xuICAgICAgICBpZihpcy5udWxsKGlucHV0JGRhdGFfZikpIHtyZXR1cm4oKX1cbiAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICByZXR1cm5NZWFuKClcbiAgICAgICAgICAgfVxuICAgICAgfSlcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgb3V0cHV0JG91dF9zdGRfVGVzdCA8LSByZW5kZXJUYWJsZSh7XG4gICAgICAgIGlmKGlzLm51bGwoaW5wdXQkZGF0YV9mKSkge3JldHVybigpfVxuICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgIHJldHVyblNURGV2KClcbiAgICAgICAgICAgfVxuICAgICAgfSlcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgb3V0cHV0JG91dF92YXJfVGVzdCA8LSByZW5kZXJUYWJsZSh7XG4gICAgICAgIGlmKGlzLm51bGwoaW5wdXQkZGF0YV9mKSkge3JldHVybigpfVxuICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgIHJldHVyblZhcmlhbmNlKClcbiAgICAgICAgICAgfVxuICAgICAgfSlcbiAgICAgICAgXG4jIyNcbiMgSE1EXG4jIyNcbiAgICAgICNtZWFuIE91dHB1dFxuICAgICAgb3V0cHV0JG91dF9NZWFuX0hNRCA8LSByZW5kZXJUYWJsZSh7XG4gICAgICAgIGlmKGlzLm51bGwoaW5wdXQkZGF0YV9ITUQpKSB7cmV0dXJuKCl9XG4gICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgcmV0dXJuTWVhbl9ITUQoKVxuICAgICAgICAgICB9XG4gICAgICB9KVxuICAgICAgICBcbiAgICAgICNTVEQgT3V0cHV0ICBcbiAgICAgIG91dHB1dCRvdXRfc3RkX0hNRCA8LSByZW5kZXJUYWJsZSh7XG4gICAgICAgIGlmKGlzLm51bGwoaW5wdXQkZGF0YV9ITUQpKSB7cmV0dXJuKCl9XG4gICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgcmV0dXJuU1REZXZfSE1EKClcbiAgICAgICAgICAgfVxuICAgICAgfSlcbiAgICAgICAgXG4gICAgICAjVmFyaWFuY2UgT3V0cHV0ICBcbiAgICAgIG91dHB1dCRvdXRfdmFyX0hNRCA8LSByZW5kZXJUYWJsZSh7XG4gICAgICAgIGlmKGlzLm51bGwoaW5wdXQkZGF0YV9ITUQpKSB7cmV0dXJuKCl9XG4gICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgcmV0dXJuVmFyaWFuY2VfSE1EKClcbiAgICAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIFxuICAgICAgI0RhdGFUYWJsZSBPdXRwdXRcbiAgICAgIG91dHB1dCRvdXRfZGF0YV9ITURfRFQgPC0gcmVuZGVyRGF0YVRhYmxlKHtcbiAgICAgICAgaWYoaXMubnVsbChpbnB1dCRkYXRhX0hNRCkpIHtyZXR1cm4oKX1cbiAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICBkYXRhX2ZpbGVfSE1EKClcbiAgICAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIFxuICAgICAgIzNEIFBsb3RcbiAgICAgIG91dHB1dCRvdXRfZGF0YV9ITURQbG90IDwtIHJlbmRlclBsb3RseSh7XG4gICAgICAgIGlmKGlzLm51bGwoaW5wdXQkZGF0YV9ITUQpKSB7cmV0dXJuKCl9XG4gICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgcGxvdEluM0RfSE1EKClcbiAgICAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIFxuIyMjXG4jIExlZnQgSGFuZCBNb3ZlbWVudFxuIyMjXG4gICAgICBcbiNtZWFuIE91dHB1dFxuICAgICAgb3V0cHV0JG91dF9NZWFuX0xlZnRIYW5kIDwtIHJlbmRlclRhYmxlKHtcbiAgICAgICAgaWYoaXMubnVsbChpbnB1dCRkYXRhX0xlZnQpKSB7cmV0dXJuKCl9XG4gICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgcmV0dXJuTWVhbl9MZWZ0KClcbiAgICAgICAgICAgfVxuICAgICAgfSlcbiAgICAgICAgXG4gICAgICAjU1REIE91dHB1dCAgXG4gICAgICBvdXRwdXQkb3V0X3N0ZF9MZWZ0SGFuZCA8LSByZW5kZXJUYWJsZSh7XG4gICAgICAgIGlmKGlzLm51bGwoaW5wdXQkZGF0YV9MZWZ0KSkge3JldHVybigpfVxuICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgIHJldHVyblNURGV2X0xlZnQoKVxuICAgICAgICAgICB9XG4gICAgICB9KVxuICAgICAgICBcbiAgICAgICNWYXJpYW5jZSBPdXRwdXQgIFxuICAgICAgb3V0cHV0JG91dF92YXJfTGVmdEhhbmQgPC0gcmVuZGVyVGFibGUoe1xuICAgICAgICBpZihpcy5udWxsKGlucHV0JGRhdGFfTGVmdCkpIHtyZXR1cm4oKX1cbiAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICByZXR1cm5WYXJpYW5jZV9MZWZ0KClcbiAgICAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIFxuICAgICAgI0RhdGFUYWJsZSBPdXRwdXRcbiAgICAgIG91dHB1dCRvdXRfZGF0YV9MZWZ0X0RUIDwtIHJlbmRlckRhdGFUYWJsZSh7XG4gICAgICAgIGlmKGlzLm51bGwoaW5wdXQkZGF0YV9MZWZ0KSkge3JldHVybigpfVxuICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgIGRhdGFfZmlsZV9MZWZ0KClcbiAgICAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIFxuICAgICAgIzNEIFBsb3RcbiAgICAgIG91dHB1dCRvdXRfZGF0YV9MZWZ0SGFuZDNEIDwtIHJlbmRlclBsb3RseSh7XG4gICAgICAgIGlmKGlzLm51bGwoaW5wdXQkZGF0YV9MZWZ0KSkge3JldHVybigpfVxuICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgIHBsb3RJbjNEX0xlZnQoKVxuICAgICAgICAgICB9XG4gICAgICB9KVxuXG4jIyNcbiMgTWV0cmljc1xuIyMjXG4gICAgICBcbiAgICAgICNUYWJsZSBPdXRwdXRcbiAgICAgIG91dHB1dCRvdXRfZGF0YV9NZXRyaWNzX1RhYmxlIDwtIHJlbmRlclRhYmxlKHtcbiAgICAgICAgaWYgKGlzLm51bGwoaW5wdXQkZGF0YV9NZXRyaWNzKSkge1xuICAgICAgICAgIHJldHVybigpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICBkYXRhX01ldHJpY3NfVGFibGUoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgXG4gICAgICAjVGFibGUgT3V0cHV0XG4gICAgICBvdXRwdXQkb3V0X2RhdGFfTWV0cmljc19Xb3JrT25UYWJsZSA8LSByZW5kZXJUYWJsZSh7XG4gICAgICAgIGlmIChpcy5udWxsKGlucHV0JGRhdGFfTWV0cmljcykpIHtcbiAgICAgICAgICByZXR1cm4oKVxuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgb3V0X2RhdGFfTWV0cmljc19Xb3JrT25UYWJsZSgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gIFxuIyMjXG4jIFF1aXpcbiMjI1xuICAgICAgI1RhYmxlIE91dHB1dFxuICAgICAgb3V0cHV0JG91dF9kYXRhX1F1aXpfVGFibGUgPC0gcmVuZGVyVGFibGUoe1xuICAgICAgICBpZiAoaXMubnVsbChpbnB1dCRkYXRhX1F1aXopKSB7XG4gICAgICAgICAgcmV0dXJuKClcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgIGRhdGFfUXVpel9UYWJsZSgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBcbiAgICAgICNQaWUgQ2hhcnQgT3V0cHV0XG4gICAgICBvdXRwdXQkb3V0X2RhdGFfUXVpel9QaWUgPC0gcmVuZGVyUGxvdGx5KHtcbiAgICAgICAgaWYgKGlzLm51bGwoaW5wdXQkZGF0YV9RdWl6KSkge1xuICAgICAgICAgIHJldHVybigpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICBRdWl6X1BpZUNoYXJ0KClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIFxuICAgICAgI1ZhbHVlIEJveCBPdXRwdXRcbiAgICAgIG91dHB1dCRvdXRfZGF0YV9RdWl6X1ZCIDwtIHJlbmRlclZhbHVlQm94KHtcbiAgICAgICAgaWYgKGlzLm51bGwoaW5wdXQkZGF0YV9RdWl6KSkge1xuICAgICAgICAgIHJldHVybigpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICBRdWl6X1ZhbHVlQm94KClcbiAgICAgICAgICAjIGZpbGVfc3BlYyA8LSBpbnB1dCRkYXRhX1F1aXpcbiAgICAgICAgICAjIFxuICAgICAgICAgICMgZ2hnZyA8LSByZWFkLnRhYmxlKGZpbGVfc3BlYyRkYXRhcGF0aCwgaGVhZGVyID0gRiwgc2VwID0gXCIsXCIpXG4gICAgICAgICAgIyBcbiAgICAgICAgICAjIGdoZ2cgPC0gZ2hnZ1tucm93KGdoZ2cpLCAxXVxuICAgICAgICAgICMgXG4gICAgICAgICAgIyB2YWx1ZUJveChnaGdnLCBzdWJ0aXRsZSA9IFwiUXVpeiBHcmFkZVwiLCBpY29uID0gaWNvbihcIkxpc3RcIiksIGNvbG9yID0gXCJwdXJwbGVcIilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgXG59XG5cbnNoaW55QXBwKHVpLCBzZXJ2ZXIpXG5gYGAifQ== -->

```r
ui <- dashboardPage(
  skin = "red",
  dashboardHeader(title = "Final Project Dashboard"),
  
  ## Sidebar content
  dashboardSidebar(
    sidebarMenu(
      menuItem(" Dashboard", tabName = "dashboard", icon = icon("dashboard")),
      menuItem(" Right Hand Movement", tabName = "RightHandMovement", icon = icon("hand-point-right")),
      menuItem(" Head Movement", tabName = "HeadMovement", icon = icon("glyphicon glyphicon-user", lib = "glyphicon")),
      menuItem(" Left Hand Movement", tabName = "LeftHandMovement", icon = icon("hand-point-left")),
      menuItem(" Metrics", tabName = "Metrics", icon = icon("clipboard")),
      menuItem(" Quiz", tabName = "Quiz", icon = icon("feather"))
      
    )
  ),
  dashboardBody(
    tabItems(
      # First tab content
      tabItem(tabName = "dashboard",
              fluidRow(
                box( width = 12, background = "navy",
                h1(
                  "This is the Home/Dashboard Page."
                )
                ),
                box( width = 12, background = "blue",
                  h2(
                    "Navigate to other pages with the sidebar on the left"
                    )
                  ),
                
                box( width = 12, background = "light-blue",
                  h3(
                    "Only use the respective .csv files for their specific tab"
                  )
                ),
              )), 

      # Second tab content - Right Hand Movement
      tabItem(tabName = "RightHandMovement",
              h2("Right Hand Movement tab content"),
              
              #Row 
              # with File Input and Mean,STD, and Var
              fluidRow(
                
                box( title = "File Input Here", width = 6, status = "primary",
                  fileInput("data_f", "Upload data", accept = ".csv")),
                
                box( title = "Mean, Standard Deviation, and Variance", width = 6, status = "info",
                  tableOutput("out_Mean_Test"),
                  tableOutput("out_std_Test"),
                  tableOutput("out_var_Test")
                  )),
              
              #Row 
              # with 3D representation
              fluidRow(
                
                box( title = "Position graph based on time", width = 12, status = "info",
                  plotlyOutput("out_data_f5")),
                mainPanel(
                  
                )
              ),
              
              #Row
              # with data Table Output and File Meta Data
              fluidRow(
              box( width = 12, status = "info",
                title = "Right Hand Movement input Table: ",
                collapsible = T,
                fluidRow(tableOutput("out_data_f1"),
                         dataTableOutput("out_data_f2"))
                              ))), 
      
      #Third Tab Content - HMD / Camera Movement
      tabItem(tabName = "HeadMovement",
              h2("Head Movement tab content"),
              
              #Row
              # with File Input and Mean,STD, and Var
              fluidRow(
                box( title = "File Input Here", width = 6, status = "primary",
                fileInput("data_HMD", "Upload data", accept = ".csv"),
                ),
                
                box( title = "Mean, Standard Deviation, and Variance", width = 6, status = "info",
                  tableOutput("out_Mean_HMD"),
                  tableOutput("out_std_HMD"),
                  tableOutput("out_var_HMD")
                  )
              ),
              
              #Row
              # with 3D representation
              fluidRow(
                box(title = "Position graph based on time", width = 12, status = "info",
                    plotlyOutput("out_data_HMDPlot")
                    )
              ),
              
              #Row
              # with data Table Output and File Meta Data
              fluidRow(
                box(
                  width = 12,
                  title = "HMD / Camera Movement input Table: ", status = "info",
                  collapsible = T,
                  fluidRow(
                    tableOutput("out_data_HMD_Meta"),
                    dataTableOutput("out_data_HMD_DT"))
                  
                )
              )
              ), 
      #Fourth Tab Content - Left Hand Movement
      tabItem(tabName = "LeftHandMovement",
        h2("Left Hand Movement tab content"),
        
              #Row 
              # with File Input and Mean,STD, and Var
              fluidRow(
                
                box( title = "File Input Here", width = 6, status = "primary",
                  fileInput("data_Left", "Upload data", accept = ".csv")),
                
                box( title = "Mean, Standard Deviation, and Variance", width = 6, status = "info",
                  tableOutput("out_Mean_LeftHand"),
                  tableOutput("out_std_LeftHand"),
                  tableOutput("out_var_LeftHand")
                  )),
              
              #Row 
              # with 3D representation
              fluidRow(
                
                box( title = "Position graph based on time", width = 12, status = "info",
                  plotlyOutput("out_data_LeftHand3D")),
                mainPanel(
                )
              ),
              
              #Row
              # with data Table Output and File Meta Data
              fluidRow(
              box( width = 12,
                title = "Left Hand Movement input Table: ",
                collapsible = T, status = "info",
                fluidRow(tableOutput("out_data_Left_Meta"),
                         dataTableOutput("out_data_Left_DT"))
                
              ))
      ),
      
      #Fifth Tab Content - Metrics Results
      tabItem(tabName = "Metrics",
        h2("Metrics tab content"),
        
        #Row
        # with File Input 
        fluidRow(
          box(
            title = "File Input Here",
            width = 4, status = "primary",
            fileInput("data_Metrics", "Upload data", accept = ".csv")
          ),
          
          box(
            title = "Metrics Score:",
            width = 8, status = "info",
            tableOutput("out_data_Metrics_Table")
          )
        ), 
        fluidRow(
          box( title = "Things to work on", width = 6, background = "orange",
            tableOutput("out_data_Metrics_WorkOnTable")
          )
        )
      ),
      
      #Sixth Tab Content - Quiz Results
      tabItem(tabName = "Quiz",
              h2("Quiz tab content"),
              #Row
              # with File Input
              fluidRow(
                box(
                  title = "File Input Here",
                  width = 4, status = "primary",
                  fileInput("data_Quiz", "Upload data", accept = ".csv")
                ),
                box(
                  title = "Quiz Score:",
                  width = 8, status = "info",
                  tableOutput("out_data_Quiz_Table")
                )
              ),
              fluidRow(
                box(
                  title = "Right vs. Wrong",
                  width = 6, status = "info",
                  plotlyOutput("out_data_Quiz_Pie")
                ),
                
                  title = "Quiz %",
                  width = 6,
                  valueBoxOutput("out_data_Quiz_VB")
                  
              ))
    )
  )
)

server <- function(input, output) {
  set.seed(122)
  histdata <- rnorm(500)
  
  
  output$Histogram <- renderPlot({
    data <- histdata[seq_len(input$slider)]
    hist(data)
  })
  

  
###
# Right Hand Movement
###
  
  
  #outputting the meta data of selected file
  output$out_data_f1 <- renderTable({
      if(is.null(input$data_f)) {return()}
      else{
        input$data_f
      }
    })
    
    
  # Made a DataTable to better visualize data
    data_file <- reactive({
            if(is.null(input$data_f)) {return()}
      else{
        file_spec <- input$data_f

        #If header = T, it will skip the first line to not include words in the list
        #Keep it F since there are no headers on the data collected
        #sep will stay "," since I only have .csv files
        aa<- read.table(file_spec$datapath, header = F, sep = ",")
        
        #Cleaning the random Outliers from the data set and renaming for readability
        
        names(aa)[names(aa) == "V1"] <- "Time"
        names(aa)[names(aa) == "V2"] <- "X_Pos"
        names(aa)[names(aa) == "V3"] <- "Y_Pos"
        names(aa)[names(aa) == "V4"] <- "Z_Pos"
        names(aa)[names(aa) == "V5"] <- "X_Rot"
        names(aa)[names(aa) == "V6"] <- "Y_Rot"
        names(aa)[names(aa) == "V7"] <- "Z_Rot"
        
        aa <- subset(aa, Y_Pos > 0)
        
        aa <- datatable(aa, options = list(scrollX = T, scrollY = "250px"))
        return(aa)
      }
    })
    
    #3D plot Testing
    plotIn3D <- reactive({
            if(is.null(input$data_f)) {return()}
      else{
        file_spec <- input$data_f

        aa<- read.table(file_spec$datapath, header = F, sep = ",")
        
        #Cleaning the random Outliers from the data set
        
        names(aa)[names(aa) == "V1"] <- "Time"
        names(aa)[names(aa) == "V2"] <- "X_Pos"
        names(aa)[names(aa) == "V3"] <- "Y_Pos"
        names(aa)[names(aa) == "V4"] <- "Z_Pos"
        names(aa)[names(aa) == "V5"] <- "X_Rot"
        names(aa)[names(aa) == "V6"] <- "Y_Rot"
        names(aa)[names(aa) == "V7"] <- "Z_Rot"
        
        aa <- subset(aa, Y_Pos > 0)
          
        
        plot_ly(aa, x = aa[,2], y = aa[,3], z = aa[,4]) %>%
          add_markers(color = aa[,1], title = "Time")
      }
    })
    
    
    #Doing the Mean Table
    returnMean <- reactive({
            if(is.null(input$data_f)) {return()}
      else{
        file_spec <- input$data_f

        aa<- read.table(file_spec$datapath, header = F, sep = ",")
        
        #Cleaning the random Outliers from the data set
        
        
        aa <- subset(aa, V3 > 0)
        
        colNames <- c("X_Mean", "Y_Mean", "Z_Mean")
        fillings <- c(mean(aa[,2]),mean(aa[,3]),mean(aa[,4]))
        
        
        meanMatrix <- rbind(colNames, fillings)
        
        names(meanMatrix)[names(meanMatrix) == "V1"] <- "X_Mean"
        names(meanMatrix)[names(meanMatrix) == "V2"] <- "Y_Mean"
        names(meanMatrix)[names(meanMatrix) == "V3"] <- "Z_Mean"
        
        return(meanMatrix)
      }
    })
    
    #Doing the Standard Deviation Table
    returnSTDev <- reactive({
            if(is.null(input$data_f)) {return()}
      else{
        file_spec <- input$data_f

        aa<- read.table(file_spec$datapath, header = F, sep = ",")
        
        #Cleaning the random Outliers from the data set
        
        names(aa)[names(aa) == "V1"] <- "Time"
        names(aa)[names(aa) == "V2"] <- "X_Pos"
        names(aa)[names(aa) == "V3"] <- "Y_Pos"
        names(aa)[names(aa) == "V4"] <- "Z_Pos"
        names(aa)[names(aa) == "V5"] <- "X_Rot"
        names(aa)[names(aa) == "V6"] <- "Y_Rot"
        names(aa)[names(aa) == "V7"] <- "Z_Rot"
        
        aa <- subset(aa, Y_Pos > 0)
        
        colNames <- c("X_STD", "Y_STD", "Z_STD")
        fillings <- c(sd(aa[,2]),sd(aa[,3]),sd(aa[,4]))
        
        stdMatrix <- rbind(colNames, fillings)
        
        return(stdMatrix)
      }
    })
    
    #Doing the Variance Table
    returnVariance <- reactive({
            if(is.null(input$data_f)) {return()}
      else{
        file_spec <- input$data_f

        aa<- read.table(file_spec$datapath, header = F, sep = ",")
        
        #Cleaning the random Outliers from the data set
        
        names(aa)[names(aa) == "V1"] <- "Time"
        names(aa)[names(aa) == "V2"] <- "X_Pos"
        names(aa)[names(aa) == "V3"] <- "Y_Pos"
        names(aa)[names(aa) == "V4"] <- "Z_Pos"
        names(aa)[names(aa) == "V5"] <- "X_Rot"
        names(aa)[names(aa) == "V6"] <- "Y_Rot"
        names(aa)[names(aa) == "V7"] <- "Z_Rot"
        
        aa <- subset(aa, Y_Pos > 0)
        
        colNames <- c("X_Var", "Y_Var", "Z_Var")
        fillings <- c(var(aa[,2]),var(aa[,3]),var(aa[,4]))
        
        varMatrix <- rbind(colNames, fillings)
        
        return(varMatrix)
      }
    })
    
###
# HMD
###
    
    
    #outputting the meta data of selected file
    output$out_data_HMD_Meta <- renderTable({
      if (is.null(input$data_HMD)) {
        return()
      }
      else{
        input$data_HMD
      }
    })
    #Doing the Mean Table for HMD
    returnMean_HMD <- reactive({
            if(is.null(input$data_HMD)) {return()}
      else{
        file_spec <- input$data_HMD

        aa<- read.table(file_spec$datapath, header = F, sep = ",")
        
        #Cleaning the random Outliers from the data set
        
        
        colNames <- c("X_Mean", "Y_Mean", "Z_Mean")
        fillings <- c(mean(aa[,2]),mean(aa[,3]),mean(aa[,4]))
        
        
        meanMatrix <- rbind(colNames, fillings)
        
        names(meanMatrix)[names(meanMatrix) == "V1"] <- "X_Mean"
        names(meanMatrix)[names(meanMatrix) == "V2"] <- "Y_Mean"
        names(meanMatrix)[names(meanMatrix) == "V3"] <- "Z_Mean"
        
        return(meanMatrix)
      }
    })
    
    #Doing the Standard Deviation Table
    returnSTDev_HMD <- reactive({
            if(is.null(input$data_HMD)) {return()}
      else{
        file_spec <- input$data_HMD

        aa<- read.table(file_spec$datapath, header = F, sep = ",")
        
        #Cleaning the random Outliers from the data set
        
        names(aa)[names(aa) == "V1"] <- "Time"
        names(aa)[names(aa) == "V2"] <- "X_Pos"
        names(aa)[names(aa) == "V3"] <- "Y_Pos"
        names(aa)[names(aa) == "V4"] <- "Z_Pos"
        names(aa)[names(aa) == "V5"] <- "X_Rot"
        names(aa)[names(aa) == "V6"] <- "Y_Rot"
        names(aa)[names(aa) == "V7"] <- "Z_Rot"
        

        colNames <- c("X_STD", "Y_STD", "Z_STD")
        fillings <- c(sd(aa[,2]),sd(aa[,3]),sd(aa[,4]))
        
        stdMatrix <- rbind(colNames, fillings)
        
        return(stdMatrix)
      }
    })
    
    #Doing the Variance Table
    returnVariance_HMD <- reactive({
            if(is.null(input$data_HMD)) {return()}
      else{
        file_spec <- input$data_HMD

        aa<- read.table(file_spec$datapath, header = F, sep = ",")
        
        #Cleaning the random Outliers from the data set
        
        names(aa)[names(aa) == "V1"] <- "Time"
        names(aa)[names(aa) == "V2"] <- "X_Pos"
        names(aa)[names(aa) == "V3"] <- "Y_Pos"
        names(aa)[names(aa) == "V4"] <- "Z_Pos"
        names(aa)[names(aa) == "V5"] <- "X_Rot"
        names(aa)[names(aa) == "V6"] <- "Y_Rot"
        names(aa)[names(aa) == "V7"] <- "Z_Rot"
        

        colNames <- c("X_Var", "Y_Var", "Z_Var")
        fillings <- c(var(aa[,2]),var(aa[,3]),var(aa[,4]))
        
        varMatrix <- rbind(colNames, fillings)
        
        return(varMatrix)
      }
    })
    
    # Made a DataTable to better visualize data
    data_file_HMD <- reactive({
            if(is.null(input$data_HMD)) {return()}
      else{
        file_spec <- input$data_HMD

        #If header = T, it will skip the first line to not include words in the list
        #Keep it F since there are no headers on the data collected
        #sep will stay "," since I only have .csv files
        aa<- read.table(file_spec$datapath, header = F, sep = ",")
        
        #Cleaning the random Outliers from the data set and renaming for readability
        
        names(aa)[names(aa) == "V1"] <- "Time"
        names(aa)[names(aa) == "V2"] <- "X_Pos"
        names(aa)[names(aa) == "V3"] <- "Y_Pos"
        names(aa)[names(aa) == "V4"] <- "Z_Pos"
        names(aa)[names(aa) == "V5"] <- "X_Rot"
        names(aa)[names(aa) == "V6"] <- "Y_Rot"
        names(aa)[names(aa) == "V7"] <- "Z_Rot"
        

        aa <- datatable(aa, options = list(scrollX = T, scrollY = "250px"))
        return(aa)
        #return(datatable(aa, options = list(scrollX = T, scrollY = "250px")))
      }
    })
    
    
    #3D plotting Head Mounted Display
    plotIn3D_HMD <- reactive({
            if(is.null(input$data_HMD)) {return()}
      else{
        file_spec <- input$data_HMD

        aa<- read.table(file_spec$datapath, header = F, sep = ",")
        
        #Cleaning the random Outliers from the data set

        plot_ly(aa, x = aa[,2], y = aa[,3], z = aa[,4]) %>%
          add_markers(color = aa[,1], title = "Time")
      }
    })
    
###
# Left Hand
###
    
  
  #outputting the meta data of selected file
  output$out_data_Left_Meta <- renderTable({
      if(is.null(input$data_Left)) {return()}
      else{
        input$data_Left
      }
    })
    
    
  # Made a DataTable to better visualize data
    data_file_Left <- reactive({
            if(is.null(input$data_Left)) {return()}
      else{
        file_spec <- input$data_Left

        #If header = T, it will skip the first line to not include words in the list
        #Keep it F since there are no headers on the data collected
        #sep will stay "," since I only have .csv files
        aa<- read.table(file_spec$datapath, header = F, sep = ",")
        
        #Cleaning the random Outliers from the data set and renaming for readability
        
        names(aa)[names(aa) == "V1"] <- "Time"
        names(aa)[names(aa) == "V2"] <- "X_Pos"
        names(aa)[names(aa) == "V3"] <- "Y_Pos"
        names(aa)[names(aa) == "V4"] <- "Z_Pos"
        names(aa)[names(aa) == "V5"] <- "X_Rot"
        names(aa)[names(aa) == "V6"] <- "Y_Rot"
        names(aa)[names(aa) == "V7"] <- "Z_Rot"
        
        aa <- subset(aa, Y_Pos > 5.95)
        
        aa <- datatable(aa, options = list(scrollX = T, scrollY = "250px"))
        return(aa)
      }
    })
    
    #3D plot Testing
    plotIn3D_Left <- reactive({
            if(is.null(input$data_Left)) {return()}
      else{
        file_spec <- input$data_Left

        aa<- read.table(file_spec$datapath, header = F, sep = ",")
        
        #Cleaning the random Outliers from the data set
        
        names(aa)[names(aa) == "V1"] <- "Time"
        names(aa)[names(aa) == "V2"] <- "X_Pos"
        names(aa)[names(aa) == "V3"] <- "Y_Pos"
        names(aa)[names(aa) == "V4"] <- "Z_Pos"
        names(aa)[names(aa) == "V5"] <- "X_Rot"
        names(aa)[names(aa) == "V6"] <- "Y_Rot"
        names(aa)[names(aa) == "V7"] <- "Z_Rot"
        
        aa <- subset(aa, Y_Pos > 5.95)
          
        
        plot_ly(aa, x = aa[,2], y = aa[,3], z = aa[,4]) %>%
          add_markers(color = aa[,1], title = "Time")
      }
    })
    
    
    #Doing the Mean Table
    returnMean_Left <- reactive({
            if(is.null(input$data_Left)) {return()}
      else{
        file_spec <- input$data_Left

        aa<- read.table(file_spec$datapath, header = F, sep = ",")
        
        #Cleaning the random Outliers from the data set
        
        
        aa <- subset(aa, V3 > 5.95)
        
        colNames <- c("X_Mean", "Y_Mean", "Z_Mean")
        fillings <- c(mean(aa[,2]),mean(aa[,3]),mean(aa[,4]))
        
        
        meanMatrix <- rbind(colNames, fillings)
        
        names(meanMatrix)[names(meanMatrix) == "V1"] <- "X_Mean"
        names(meanMatrix)[names(meanMatrix) == "V2"] <- "Y_Mean"
        names(meanMatrix)[names(meanMatrix) == "V3"] <- "Z_Mean"
        
        return(meanMatrix)
      }
    })
    
    #Doing the Standard Deviation Table
    returnSTDev_Left <- reactive({
            if(is.null(input$data_Left)) {return()}
      else{
        file_spec <- input$data_Left

        aa<- read.table(file_spec$datapath, header = F, sep = ",")
        
        #Cleaning the random Outliers from the data set
        
        names(aa)[names(aa) == "V1"] <- "Time"
        names(aa)[names(aa) == "V2"] <- "X_Pos"
        names(aa)[names(aa) == "V3"] <- "Y_Pos"
        names(aa)[names(aa) == "V4"] <- "Z_Pos"
        names(aa)[names(aa) == "V5"] <- "X_Rot"
        names(aa)[names(aa) == "V6"] <- "Y_Rot"
        names(aa)[names(aa) == "V7"] <- "Z_Rot"
        
        aa <- subset(aa, Y_Pos > 0)
        
        colNames <- c("X_STD", "Y_STD", "Z_STD")
        fillings <- c(sd(aa[,2]),sd(aa[,3]),sd(aa[,4]))
        
        stdMatrix <- rbind(colNames, fillings)
        
        return(stdMatrix)
      }
    })
    
    #Doing the Variance Table
    returnVariance_Left <- reactive({
            if(is.null(input$data_Left)) {return()}
      else{
        file_spec <- input$data_Left

        aa<- read.table(file_spec$datapath, header = F, sep = ",")
        
        #Cleaning the random Outliers from the data set
        
        names(aa)[names(aa) == "V1"] <- "Time"
        names(aa)[names(aa) == "V2"] <- "X_Pos"
        names(aa)[names(aa) == "V3"] <- "Y_Pos"
        names(aa)[names(aa) == "V4"] <- "Z_Pos"
        names(aa)[names(aa) == "V5"] <- "X_Rot"
        names(aa)[names(aa) == "V6"] <- "Y_Rot"
        names(aa)[names(aa) == "V7"] <- "Z_Rot"
        
        aa <- subset(aa, Y_Pos > 0)
        
        colNames <- c("X_Var", "Y_Var", "Z_Var")
        fillings <- c(var(aa[,2]),var(aa[,3]),var(aa[,4]))
        
        varMatrix <- rbind(colNames, fillings)
        
        return(varMatrix)
      }
    })
    
    
###
# Metrics
###
    
      # Made a DataTable to better visualize data
    data_Metrics_Table <- reactive({
            if(is.null(input$data_Metrics)) {return()}
      else{
        file_spec <- input$data_Metrics

        #If header = T, it will skip the first line to not include words in the list
        #Keep it F since there are no headers on the data collected
        #sep will stay "," since I only have .csv files
        aa<- read.table(file_spec$datapath, header = F, sep = ",")
        
        names(aa)[names(aa) == "V1"] <- "Time"
        names(aa)[names(aa) == "V2"] <- "Metric Number"
        names(aa)[names(aa) == "V3"] <- "Score"
        
        return(aa)
      }
    })
    
    out_data_Metrics_WorkOnTable <- reactive({
            if(is.null(input$data_Metrics)) {return()}
      else{
        file_spec <- input$data_Metrics

        #If header = T, it will skip the first line to not include words in the list
        #Keep it F since there are no headers on the data collected
        #sep will stay "," since I only have .csv files
        aa<- read.table(file_spec$datapath, header = F, sep = ",")
        
        names(aa)[names(aa) == "V1"] <- "Time"
        names(aa)[names(aa) == "V2"] <- "Metric Number"
        names(aa)[names(aa) == "V3"] <- "Score"
        
        WO <- c()
        
        for (num in 1:nrow(aa)) {
          if(aa[num,3] < 5){
            WO <- aa[num,]
          }
        }
        
        return(WO)
      }
    })
    
    
    
    
###
# Quiz
###
    
      # Made a DataTable to better visualize data
    data_Quiz_Table <- reactive({
            if(is.null(input$data_Quiz)) {return()}
      else{
        file_spec <- input$data_Quiz

        #If header = T, it will skip the first line to not include words in the list
        #Keep it F since there are no headers on the data collected
        #sep will stay "," since I only have .csv files
        aa<- read.table(file_spec$datapath, header = F, sep = ",")
        
        names(aa)[names(aa) == "V1"] <- "Step Number"
        names(aa)[names(aa) == "V2"] <- "Correct or Incorrect"

        return(aa)
      }
    })
    
    
    
    #3D plot Testing
    Quiz_PieChart <- reactive({
            if(is.null(input$data_Quiz)) {return()}
      else{
        file_spec <- input$data_Quiz

        aa<- read.table(file_spec$datapath, header = F, sep = ",")
        
        #Take out the final row that is the %
         aa <- aa[1:(nrow(aa)-1),]
         Ccounter <- 0
         Wcounter <- 0
         
         for (num in 1:(nrow(aa)-1)) {
           if(aa[num,2] == T || aa[num,2] == 1 || aa[num,2] == "TRUE"){
             Ccounter <- Ccounter+1
           }else if(aa[num,2] == F || aa[num,2] == 0 || aa[num,2] == "FALSE"){
             Wcounter <- Wcounter + 1
           }
         } 
         CNames <- c("Correct", "Incorrect")
         scores <- c(Ccounter, Wcounter)
         
         
         fig <-
           plot_ly(
             x = CNames,
             y = scores,
             type = "bar",
             base = 0,
             
             name = c("Correct", "Incorrect"),color = CNames, colors = c("#0B6623", "#800000")
           )
         
        return(fig)
      }
    })
    
    Quiz_ValueBox <- reactive({
      if(is.null(input$data_Quiz)) {return()}
      else{
        file_spec <- input$data_Quiz
        
        QB<- read.table(file_spec$datapath, header = F, sep = ",")

        QB <- QB[nrow(QB),1]
        
        return(valueBox(
          QB, subtitle = "Quiz Grade", icon = icon("percent"), color = "teal"
        ))
      }
      
    })
    
    
    
###########
    
    #Outputs to place onto an output object
    
      output$out_data_f2 <- renderDataTable({
                    if(is.null(input$data_f)) {return()}
        else{
          data_file()
        }

      })
      
      
      
      output$out_data_f5 <- renderPlotly({
        if(is.null(input$data_f)) {return()}
           else{
             plotIn3D()
           }
      })
      
        
      output$out_Mean_Test <- renderTable({
        if(is.null(input$data_f)) {return()}
           else{
             returnMean()
           }
      })
        
        
      output$out_std_Test <- renderTable({
        if(is.null(input$data_f)) {return()}
           else{
             returnSTDev()
           }
      })
        
        
      output$out_var_Test <- renderTable({
        if(is.null(input$data_f)) {return()}
           else{
             returnVariance()
           }
      })
        
###
# HMD
###
      #mean Output
      output$out_Mean_HMD <- renderTable({
        if(is.null(input$data_HMD)) {return()}
           else{
             returnMean_HMD()
           }
      })
        
      #STD Output  
      output$out_std_HMD <- renderTable({
        if(is.null(input$data_HMD)) {return()}
           else{
             returnSTDev_HMD()
           }
      })
        
      #Variance Output  
      output$out_var_HMD <- renderTable({
        if(is.null(input$data_HMD)) {return()}
           else{
             returnVariance_HMD()
           }
      })
      
      #DataTable Output
      output$out_data_HMD_DT <- renderDataTable({
        if(is.null(input$data_HMD)) {return()}
           else{
             data_file_HMD()
           }
      })
      
      #3D Plot
      output$out_data_HMDPlot <- renderPlotly({
        if(is.null(input$data_HMD)) {return()}
           else{
             plotIn3D_HMD()
           }
      })
      
###
# Left Hand Movement
###
      
#mean Output
      output$out_Mean_LeftHand <- renderTable({
        if(is.null(input$data_Left)) {return()}
           else{
             returnMean_Left()
           }
      })
        
      #STD Output  
      output$out_std_LeftHand <- renderTable({
        if(is.null(input$data_Left)) {return()}
           else{
             returnSTDev_Left()
           }
      })
        
      #Variance Output  
      output$out_var_LeftHand <- renderTable({
        if(is.null(input$data_Left)) {return()}
           else{
             returnVariance_Left()
           }
      })
      
      #DataTable Output
      output$out_data_Left_DT <- renderDataTable({
        if(is.null(input$data_Left)) {return()}
           else{
             data_file_Left()
           }
      })
      
      #3D Plot
      output$out_data_LeftHand3D <- renderPlotly({
        if(is.null(input$data_Left)) {return()}
           else{
             plotIn3D_Left()
           }
      })

###
# Metrics
###
      
      #Table Output
      output$out_data_Metrics_Table <- renderTable({
        if (is.null(input$data_Metrics)) {
          return()
        }
        else{
          data_Metrics_Table()
        }
      })
      
      #Table Output
      output$out_data_Metrics_WorkOnTable <- renderTable({
        if (is.null(input$data_Metrics)) {
          return()
        }
        else{
          out_data_Metrics_WorkOnTable()
        }
      })
  
###
# Quiz
###
      #Table Output
      output$out_data_Quiz_Table <- renderTable({
        if (is.null(input$data_Quiz)) {
          return()
        }
        else{
          data_Quiz_Table()
        }
      })
      
      #Pie Chart Output
      output$out_data_Quiz_Pie <- renderPlotly({
        if (is.null(input$data_Quiz)) {
          return()
        }
        else{
          Quiz_PieChart()
        }
      })
      
      #Value Box Output
      output$out_data_Quiz_VB <- renderValueBox({
        if (is.null(input$data_Quiz)) {
          return()
        }
        else{
          Quiz_ValueBox()
          # file_spec <- input$data_Quiz
          # 
          # ghgg <- read.table(file_spec$datapath, header = F, sep = ",")
          # 
          # ghgg <- ghgg[nrow(ghgg), 1]
          # 
          # valueBox(ghgg, subtitle = "Quiz Grade", icon = icon("List"), color = "purple")
        }
      })
      
      
      
      
      
}

shinyApp(ui, server)
```

<!-- rnb-source-end -->

<!-- rnb-output-begin eyJkYXRhIjoiXG5MaXN0ZW5pbmcgb24gaHR0cDovLzEyNy4wLjAuMTo1NDgzXG5XYXJuaW5nOiAnc2NhdHRlcjNkJyBvYmplY3RzIGRvbid0IGhhdmUgdGhlc2UgYXR0cmlidXRlczogJ3RpdGxlJ1xuVmFsaWQgYXR0cmlidXRlcyBpbmNsdWRlOlxuJ2Nvbm5lY3RnYXBzJywgJ2N1c3RvbWRhdGEnLCAnY3VzdG9tZGF0YXNyYycsICdlcnJvcl94JywgJ2Vycm9yX3knLCAnZXJyb3JfeicsICdob3ZlcmluZm8nLCAnaG92ZXJpbmZvc3JjJywgJ2hvdmVybGFiZWwnLCAnaG92ZXJ0ZW1wbGF0ZScsICdob3ZlcnRlbXBsYXRlc3JjJywgJ2hvdmVydGV4dCcsICdob3ZlcnRleHRzcmMnLCAnaWRzJywgJ2lkc3NyYycsICdsZWdlbmRncm91cCcsICdsZWdlbmRncm91cHRpdGxlJywgJ2xlZ2VuZHJhbmsnLCAnbGluZScsICdtYXJrZXInLCAnbWV0YScsICdtZXRhc3JjJywgJ21vZGUnLCAnbmFtZScsICdvcGFjaXR5JywgJ3Byb2plY3Rpb24nLCAnc2NlbmUnLCAnc2hvd2xlZ2VuZCcsICdzdHJlYW0nLCAnc3VyZmFjZWF4aXMnLCAnc3VyZmFjZWNvbG9yJywgJ3RleHQnLCAndGV4dGZvbnQnLCAndGV4dHBvc2l0aW9uJywgJ3RleHRwb3NpdGlvbnNyYycsICd0ZXh0c3JjJywgJ3RleHR0ZW1wbGF0ZScsICd0ZXh0dGVtcGxhdGVzcmMnLCAndHJhbnNmb3JtcycsICd0eXBlJywgJ3VpZCcsICd1aXJldmlzaW9uJywgJ3Zpc2libGUnLCAneCcsICd4Y2FsZW5kYXInLCAneGhvdmVyZm9ybWF0JywgJ3hzcmMnLCAneScsICd5Y2FsZW5kYXInLCAneWhvdmVyZm9ybWF0JywgJ3lzcmMnLCAneicsICd6Y2FsZW5kYXInLCAnemhvdmVyZm9ybWF0JywgJ3pzcmMnLCAna2V5JywgJ3NldCcsICdmcmFtZScsICd0cmFuc2Zvcm1zJywgJ19pc05lc3RlZEtleScsICdfaXNTaW1wbGVLZXknLCAnX2lzR3JhdGljdWxlJywgJ19iYm94J1xuV2FybmluZzogJ3NjYXR0ZXIzZCcgb2JqZWN0cyBkb24ndCBoYXZlIHRoZXNlIGF0dHJpYnV0ZXM6ICd0aXRsZSdcblZhbGlkIGF0dHJpYnV0ZXMgaW5jbHVkZTpcbidjb25uZWN0Z2FwcycsICdjdXN0b21kYXRhJywgJ2N1c3RvbWRhdGFzcmMnLCAnZXJyb3JfeCcsICdlcnJvcl95JywgJ2Vycm9yX3onLCAnaG92ZXJpbmZvJywgJ2hvdmVyaW5mb3NyYycsICdob3ZlcmxhYmVsJywgJ2hvdmVydGVtcGxhdGUnLCAnaG92ZXJ0ZW1wbGF0ZXNyYycsICdob3ZlcnRleHQnLCAnaG92ZXJ0ZXh0c3JjJywgJ2lkcycsICdpZHNzcmMnLCAnbGVnZW5kZ3JvdXAnLCAnbGVnZW5kZ3JvdXB0aXRsZScsICdsZWdlbmRyYW5rJywgJ2xpbmUnLCAnbWFya2VyJywgJ21ldGEnLCAnbWV0YXNyYycsICdtb2RlJywgJ25hbWUnLCAnb3BhY2l0eScsICdwcm9qZWN0aW9uJywgJ3NjZW5lJywgJ3Nob3dsZWdlbmQnLCAnc3RyZWFtJywgJ3N1cmZhY2VheGlzJywgJ3N1cmZhY2Vjb2xvcicsICd0ZXh0JywgJ3RleHRmb250JywgJ3RleHRwb3NpdGlvbicsICd0ZXh0cG9zaXRpb25zcmMnLCAndGV4dHNyYycsICd0ZXh0dGVtcGxhdGUnLCAndGV4dHRlbXBsYXRlc3JjJywgJ3RyYW5zZm9ybXMnLCAndHlwZScsICd1aWQnLCAndWlyZXZpc2lvbicsICd2aXNpYmxlJywgJ3gnLCAneGNhbGVuZGFyJywgJ3hob3ZlcmZvcm1hdCcsICd4c3JjJywgJ3knLCAneWNhbGVuZGFyJywgJ3lob3ZlcmZvcm1hdCcsICd5c3JjJywgJ3onLCAnemNhbGVuZGFyJywgJ3pob3ZlcmZvcm1hdCcsICd6c3JjJywgJ2tleScsICdzZXQnLCAnZnJhbWUnLCAndHJhbnNmb3JtcycsICdfaXNOZXN0ZWRLZXknLCAnX2lzU2ltcGxlS2V5JywgJ19pc0dyYXRpY3VsZScsICdfYmJveCdcbiJ9 -->

```

Listening on http://127.0.0.1:5483
Warning: 'scatter3d' objects don't have these attributes: 'title'
Valid attributes include:
'connectgaps', 'customdata', 'customdatasrc', 'error_x', 'error_y', 'error_z', 'hoverinfo', 'hoverinfosrc', 'hoverlabel', 'hovertemplate', 'hovertemplatesrc', 'hovertext', 'hovertextsrc', 'ids', 'idssrc', 'legendgroup', 'legendgrouptitle', 'legendrank', 'line', 'marker', 'meta', 'metasrc', 'mode', 'name', 'opacity', 'projection', 'scene', 'showlegend', 'stream', 'surfaceaxis', 'surfacecolor', 'text', 'textfont', 'textposition', 'textpositionsrc', 'textsrc', 'texttemplate', 'texttemplatesrc', 'transforms', 'type', 'uid', 'uirevision', 'visible', 'x', 'xcalendar', 'xhoverformat', 'xsrc', 'y', 'ycalendar', 'yhoverformat', 'ysrc', 'z', 'zcalendar', 'zhoverformat', 'zsrc', 'key', 'set', 'frame', 'transforms', '_isNestedKey', '_isSimpleKey', '_isGraticule', '_bbox'
Warning: 'scatter3d' objects don't have these attributes: 'title'
Valid attributes include:
'connectgaps', 'customdata', 'customdatasrc', 'error_x', 'error_y', 'error_z', 'hoverinfo', 'hoverinfosrc', 'hoverlabel', 'hovertemplate', 'hovertemplatesrc', 'hovertext', 'hovertextsrc', 'ids', 'idssrc', 'legendgroup', 'legendgrouptitle', 'legendrank', 'line', 'marker', 'meta', 'metasrc', 'mode', 'name', 'opacity', 'projection', 'scene', 'showlegend', 'stream', 'surfaceaxis', 'surfacecolor', 'text', 'textfont', 'textposition', 'textpositionsrc', 'textsrc', 'texttemplate', 'texttemplatesrc', 'transforms', 'type', 'uid', 'uirevision', 'visible', 'x', 'xcalendar', 'xhoverformat', 'xsrc', 'y', 'ycalendar', 'yhoverformat', 'ysrc', 'z', 'zcalendar', 'zhoverformat', 'zsrc', 'key', 'set', 'frame', 'transforms', '_isNestedKey', '_isSimpleKey', '_isGraticule', '_bbox'
```



<!-- rnb-output-end -->

<!-- rnb-output-begin eyJkYXRhIjoiTlVMTFxuIn0= -->

```
NULL
```



<!-- rnb-output-end -->

<!-- rnb-output-begin eyJkYXRhIjoiV2FybmluZzogRXJyb3IgaW4gdGFnQXNzZXJ0OiBFeHBlY3RlZCBhbiBvYmplY3Qgd2l0aCBjbGFzcyAnc2hpbnkudGFnJy4gIDEwMTogc3RvcFxuICAxMDA6IHRhZ0Fzc2VydFxuICAgOTk6IHJlbmRlclVJXG4gICA5ODogZnVuY1xuICAgODU6IHJlbmRlckZ1bmNcbiAgIDg0OiBvdXRwdXQkb3V0X2RhdGFfUXVpel9WQlxuICAgIDM6IHJ1bkFwcFxuICAgIDI6IHByaW50LnNoaW55LmFwcG9ialxuICAgIDE6IDxBbm9ueW1vdXM+XG4ifQ== -->

```
Warning: Error in tagAssert: Expected an object with class 'shiny.tag'.  101: stop
  100: tagAssert
   99: renderUI
   98: func
   85: renderFunc
   84: output$out_data_Quiz_VB
    3: runApp
    2: print.shiny.appobj
    1: <Anonymous>
```



<!-- rnb-output-end -->

<!-- rnb-output-begin eyJkYXRhIjoiTkFcbiJ9 -->

```
NA
```



<!-- rnb-output-end -->

<!-- rnb-chunk-end -->


<!-- rnb-text-begin -->




<!-- rnb-text-end -->

